using System.Globalization;

namespace System.ServiceModel {
	static partial class SR {
		
	internal static string GetString(string name, params object[] args)
	{
		return GetString (CultureInfo.InvariantCulture, name, args);
	}

	internal static string GetString(CultureInfo culture, string name, params object[] args)
	{
		return string.Format (culture, name, args);
	}

	internal static string GetString(string name)
	{
		return name;
	}

	internal static string GetString(CultureInfo culture, string name)
	{
		return name;
	}
		
		
public const string MessageVersionToStringFormat = @"{0} {1}";
public const string Addressing10ToStringFormat = @"Addressing10 ({0})";
public const string Addressing200408ToStringFormat = @"Addressing200408 ({0})";
public const string AddressingNoneToStringFormat = @"AddressingNone ({0})";
public const string Soap11ToStringFormat = @"Soap11 ({0})";
public const string Soap12ToStringFormat = @"Soap12 ({0})";
public const string EnvelopeNoneToStringFormat = @"EnvelopeNone ({0})";
public const string MessageBodyIsUnknown = @"...";
public const string MessageBodyIsStream = @"... stream ...";




public const string NoIPEndpointsFoundForHost = @"No IPEndpoints were found for host {0}.";
public const string DnsResolveFailed = @"No DNS entries exist for host {0}.";
public const string RequiredAttributeMissing = @"Attribute '{0}' is required on element '{1}'.";
public const string UnsupportedCryptoAlgorithm = @"Crypto algorithm '{0}' not supported in this context.";
public const string NoKeyInfoClausesToWrite = @"The SecurityKeyIdentifier has no key identifier clauses to write.";
public const string TokenSerializerNotSetonFederationProvider = @"The security token serializer must be specified on the security token provider.";
public const string IssuerBindingNotPresentInTokenRequirement = @"The key length '{0}' is not a multiple of 8 for symmetric keys.";
public const string IssuerChannelBehaviorsCannotContainSecurityCredentialsManager = @"The channel behaviors configured for the issuer address '{0}' cannot contain a behavior of type '{1}'.";
public const string SecurityTokenManagerCannotCreateProviderForRequirement = @"The security token manager cannot create a token provider for requirement '{0}'.";
public const string SecurityTokenManagerCannotCreateAuthenticatorForRequirement = @"The security token manager cannot create a token authenticator for requirement '{0}'.";
public const string FailedSignatureVerification = @"The signature verification failed. Please see inner exception for fault details.";
public const string SecurityTokenManagerCannotCreateSerializerForVersion = @"The security token manager cannot create a token serializer for security token version '{0}'.";
public const string SupportingSignatureIsNotDerivedFrom = @"The supporting signature is not signed with a derived key. The binding's supporting token parameter '{0}' requires key derivation.";
public const string PrimarySignatureWasNotSignedByDerivedKey = @"The primary signature is not signed with a derived key. The binding's primary token parameter '{0}' requires key derivation.";
public const string PrimarySignatureWasNotSignedByDerivedWrappedKey = @"The primary signature is not signed with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.";
public const string MessageWasNotEncryptedByDerivedWrappedKey = @"The message is not encrypted with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.";
public const string MessageWasNotEncryptedByDerivedEncryptionToken = @"The message is not encrypted with a key derived from the encryption token. The binding's token parameter '{0}' requires key derivation.";
public const string TokenAuthenticatorRequiresSecurityBindingElement = @"The security token manager requires the security binding element to be specified in order to create a token authenticator for requirement '{0}'.";
public const string TokenProviderRequiresSecurityBindingElement = @"The security token manager requires the security binding element to be specified in order to create a token provider for requirement '{0}'.";
public const string UnexpectedSecuritySessionCloseResponse = @"The security session received an unexpected close response from the other party.";
public const string UnexpectedSecuritySessionClose = @"The security session received an unexpected close from the other party.";
public const string CannotObtainSslConnectionInfo = @"The service was unable to verify the cipher strengths negotiated as part of the SSL handshake.";
public const string HeaderEncryptionNotSupportedInWsSecurityJan2004 = @"SecurityVersion.WSSecurityJan2004 does not support header encryption. Header with name '{0}' and namespace '{1}' is configured for encryption. Consider using SecurityVersion.WsSecurity11 and above or use transport security to encrypt the full message.";
public const string EncryptedHeaderNotSigned = @"The Header ('{0}', '{1}') was encrypted but not signed. All encrypted headers outside the security header should be signed.";
public const string EncodingBindingElementDoesNotHandleReaderQuotas = @"Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty<T>() method.";
public const string HeaderDecryptionNotSupportedInWsSecurityJan2004 = @"SecurityVersion.WSSecurityJan2004 does not support header decryption. Use SecurityVersion.WsSecurity11 and above or use transport security to encrypt the full message.";
public const string DecryptionFailed = @"Unable to decrypt an encrypted data block. Please verify that the encryption algorithm and keys used by the sender and receiver match.";
public const string SamlUriCannotBeNullOrEmpty = @"The SAML uri specified as part of the SAML security key identifier clause cannot be null or empty.";
public const string AssertionIdCannotBeNullOrEmpty = @"The assertion id specified as part of the SAML security key identifier clause cannot be null or empty.";
public const string ErrorSerializingSecurityToken = @"There was an error serializing the security token. Please see the inner exception for more details.";
public const string ErrorSerializingKeyIdentifier = @"There was an error serializing the security key identifier. Please see the inner exception for more details.";
public const string ErrorSerializingKeyIdentifierClause = @"There was an error serializing the security key identifier clause. Please see the inner exception for more details.";
public const string ErrorDeserializingKeyIdentifierClauseFromTokenXml = @"There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.";
public const string ErrorDeserializingTokenXml = @"There was an error deserializing the security token XML. Please see the inner exception for more details.";
public const string ErrorDeserializingKeyIdentifier = @"There was an error deserializing the security key identifier XML. Please see the inner exception for more details.";
public const string ErrorDeserializingKeyIdentifierClause = @"There was an error deserializing the security key identifier clause XML. Please see the inner exception for more details.";
public const string TokenRequirementDoesNotSpecifyTargetAddress = @"The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.";
public const string DerivedKeyNotInitialized = @"The derived key has not been computed for the security token.";
public const string IssuedKeySizeNotCompatibleWithAlgorithmSuite = @"The binding ('{0}', '{1}') has been configured with a security algorithm suite '{2}' that is incompatible with the issued token key size '{3}' specified on the binding.";
public const string IssuedTokenAuthenticationModeRequiresSymmetricIssuedKey = @"The IssuedToken security authentication mode requires the issued token to contain a symmetric key.";
public const string InvalidBearerKeyUsage = @"The binding ('{0}', '{1}') uses an Issued Token with Bearer Key Type in a invalid context. The Issued Token with a Bearer Key Type can only be used as a Signed Supporting token or a Signed Encrypted Supporting token. See the SecurityBindingElement.EndpointSupportingTokenParameters property.";
public const string RsaSHA256NotSupported = @"The binding ('{0}', '{1}') has been configured with a security algorithm suite '{2}' that is not supported.";
public const string MultipleIssuerEndpointsFound = @"Policy for multiple issuer endpoints was retrieved from '{0}' but the relying party's policy does not specify which issuer endpoint to use. One of the endpoints was selected as the issuer endpoint to use. If you are using svcutil, the other endpoints will be available in commented form in the configuration as <alternativeIssuedTokenParameters>. Check the configuration to ensure that the right issuer endpoint was selected.";
public const string MultipleSamlAuthorityBindingsInReference = @"The SecurityTokenReference to the SAML assertion contains multiple AuthorityBinding elements.";
public const string MultipleKeyIdentifiersInReference = @"The SecurityTokenReference contains multiple KeyIdentifier elements.";
public const string DidNotFindKeyIdentifierInReference = @"The SecurityTokenReference does not contain a KeyIdentifier.";
public const string MultipleSecurityCredentialsManagersInServiceBindingParameters = @"The ServiceCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the service, please first remove any existing ServiceCredentials from the behaviors collection before adding the custom credential.";
public const string MultipleSecurityCredentialsManagersInChannelBindingParameters = @"The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.";
public const string NoClientCertificate = @"The binding ('{0}', '{1}') has been configured with a MutualCertificateDuplexBindingElement that requires a client certificate. The client certificate is currently missing.";
public const string SecurityTokenParametersHasIncompatibleInclusionMode = @"The binding ('{0}', '{1}') is configured with a security token parameter '{2}' that has an incompatible security token inclusion mode '{3}'. Specify an alternate security token inclusion mode (for example, '{4}').";
public const string CannotCreateTwoWayListenerForNegotiation = @"Unable to create a bi-directional (request-reply or duplex) channel for security negotiation. Please ensure that the binding is capable of creating a bi-directional channel.";
public const string NegotiationQuotasExceededFaultReason = @"There are too many active security negotiations or secure conversations at the service. Please retry later.";
public const string PendingSessionsExceededFaultReason = @"There are too many pending secure conversations on the server. Please retry later.";
public const string RequestSecurityTokenDoesNotMatchEndpointFilters = @"The RequestSecurityToken message does not match the endpoint filters the service '{0}' is expecting incoming messages to match. This may be because the RequestSecurityToken was intended to be sent to a different service.";
public const string SecuritySessionRequiresIssuanceAuthenticator = @"The security session requires a security token authenticator that implements '{0}'. '{1}' does not implement '{0}'.";
public const string SecuritySessionRequiresSecurityContextTokenCache = @"The security session requires a security token resolver that implements '{1}'. The security token resolver '{0}' does not implement '{1}'.";
public const string SessionTokenIsNotSecurityContextToken = @"The session security token authenticator returned a token of type '{0}'. The token type expected is '{1}'.";
public const string SessionTokenIsNotGenericXmlToken = @"The session security token provider returned a token of type '{0}'. The token type expected is '{1}'.";
public const string SecurityStandardsManagerNotSet = @"The security standards manager was not specified on  '{0}'.";
public const string SecurityNegotiationMessageTooLarge = @"The security negotiation message with action '{0}' is larger than the maximum allowed buffer size '{1}'. If you are using a streamed transport consider increasing the maximum buffer size on the transport.";
public const string PreviousChannelDemuxerOpenFailed = @"The channel demuxer Open failed previously with exception '{0}'.";
public const string SecurityChannelListenerNotSet = @"The security channel listener was not specified on  '{0}'.";
public const string SecuritySettingsLifetimeManagerNotSet = @"The security settings lifetime manager was not specified on  '{0}'.";
public const string SecurityListenerClosing = @"The listener is not accepting new secure conversations because it is closing.";
public const string SecurityListenerClosingFaultReason = @"The server is not accepting new secure conversations currently because it is closing. Please retry later.";
public const string SslCipherKeyTooSmall = @"The cipher key negotiated by SSL is too small ('{0}' bits). Keys of such lengths are not allowed as they may result in information disclosure. Please configure the initiator machine to negotiate SSL cipher keys that are '{1}' bits or longer.";
public const string DerivedKeyTokenNonceTooLong = @"The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.";
public const string DerivedKeyTokenLabelTooLong = @"The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.";
public const string DerivedKeyTokenOffsetTooHigh = @"The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.";
public const string DerivedKeyTokenGenerationAndLengthTooHigh = @"The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.";
public const string DerivedKeyLimitExceeded = @"The number of derived keys in the message has exceeded the maximum allowed number '{0}'.";
public const string WrappedKeyLimitExceeded = @"The number of encrypted keys in the message has exceeded the maximum allowed number '{0}'.";
public const string BufferQuotaExceededReadingBase64 = @"Unable to finish reading Base64 data as the given buffer quota has been exceeded. Buffer quota: {0}. Consider increasing the MaxReceivedMessageSize quota on the TransportBindingElement. Please note that a very high value for MaxReceivedMessageSize will result in buffering a large message and might open the system to DOS attacks.";
public const string MessageSecurityDoesNotWorkWithManualAddressing = @"Manual addressing is not supported with message level security. Configure the binding ('{0}', '{1}') to use transport security or to not do manual addressing.";
public const string TargetAddressIsNotSet = @"The target service address was not specified on '{0}'.";
public const string IssuedTokenCacheNotSet = @"The issued token cache was not specified on '{0}'.";
public const string SecurityAlgorithmSuiteNotSet = @"The security algorithm suite was not specified on '{0}'.";
public const string SecurityTokenFoundOutsideSecurityHeader = @"A security token ('{0}', '{1}') was found outside the security header. The message may have been altered in transit.";
public const string SecureConversationCancelNotAllowedFaultReason = @"A secure conversation cancellation is not allowed by the binding.";
public const string BootstrapSecurityBindingElementNotSet = @"The security binding element for bootstrap security was not specified on '{0}'.";
public const string IssuerBuildContextNotSet = @"The context for building the issuer channel was  not specified on '{0}'.";
public const string StsBindingNotSet = @"The binding to use to communicate to the federation service at '{0}' is not specified.";
public const string SslServerCertMustDoKeyExchange = @"The certificate '{0}' must have a private key that is capable of key exchange. The process must have access rights for the private key.";
public const string SslClientCertMustHavePrivateKey = @"The certificate '{0}' must have a private key. The process must have access rights for the private key.";
public const string NoOutgoingEndpointAddressAvailableForDoingIdentityCheck = @"No outgoing EndpointAddress is available to check the identity on a message to be sent.";
public const string NoOutgoingEndpointAddressAvailableForDoingIdentityCheckOnReply = @"No outgoing EndpointAddress is available to check the identity on a received reply.";
public const string NoSigningTokenAvailableToDoIncomingIdentityCheck = @"No signing token is available to do an incoming identity check.";
public const string Psha1KeyLengthInvalid = @"The PSHA1 key length '{0}' is invalid.";
public const string CloneNotImplementedCorrectly = @"Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.";
public const string BadIssuedTokenType = @"The issued token is of unexpected type '{0}'. Expected token type '{1}'.";
public const string OperationDoesNotAllowImpersonation = @"The service operation '{0}' that belongs to the contract with the '{1}' name and the '{2}' namespace does not allow impersonation.";
public const string RstrHasMultipleIssuedTokens = @"The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.";
public const string RstrHasMultipleProofTokens = @"The RequestSecurityTokenResponse has multiple RequestedProofToken elements.";
public const string ProofTokenXmlUnexpectedInRstr = @"The proof token XML element is not expected in the response.";
public const string InvalidKeyLengthRequested = @"The key length '{0}' requested is invalid.";
public const string IssuedSecurityTokenParametersNotSet = @"The security token parameters to use for the issued token are not set on '{0}'.";
public const string InvalidOrUnrecognizedAction = @"The message could not be processed because the action '{0}' is invalid or unrecognized.";
public const string UnsupportedTokenInclusionMode = @"Token inclusion mode '{0}' is not supported.";
public const string CannotImportProtectionLevelForContract = @"The policy to import a process cannot import a binding for contract ({0},{1}). The protection requirements for the binding are not compatible with a binding already imported for the contract. You must reconfigure the binding.";
public const string OnlyOneOfEncryptedKeyOrSymmetricBindingCanBeSelected = @"The symmetric security protocol can either be configured with a symmetric token provider and a symmetric token authenticator or an asymmetric token provider. It cannot be configured with both.";
public const string ClientCredentialTypeMustBeSpecifiedForMixedMode = @"ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.";
public const string SecuritySessionIdAlreadyPresentInFilterTable = @"The security session id '{0}' is already present in the filter table.";
public const string SupportingTokenNotProvided = @"A supporting token that satisfies parameters '{0}' and attachment mode '{1}' was not provided.";
public const string SupportingTokenIsNotEndorsing = @"The supporting token provided for parameters '{0}' did not endorse the primary signature.";
public const string SupportingTokenIsNotSigned = @"The supporting token provided for parameters '{0}' was not signed as part of the primary signature.";
public const string SupportingTokenIsNotEncrypted = @"The supporting token provided for parameters '{0}' was not encrypted.";
public const string BasicTokenNotExpected = @"A basic token is not expected in the security header in this context.";
public const string FailedAuthenticationTrustFaultCode = @"The request for security token could not be satisfied because authentication failed.";
public const string AuthenticationOfClientFailed = @"The caller was not authenticated by the service.";
public const string InvalidRequestTrustFaultCode = @"The request for security token has invalid or malformed elements.";
public const string SignedSupportingTokenNotExpected = @"A signed supporting token is not expected in the security header in this context.";
public const string SenderSideSupportingTokensMustSpecifySecurityTokenParameters = @"Security token parameters must be specified with supporting tokens for each message.";
public const string SignatureAndEncryptionTokenMismatch = @"The signature token '{0}' is not the same token as the encryption token '{1}'.";
public const string RevertingPrivilegeFailed = @"The reverting operation failed with the exception '{0}'.";
public const string UnknownSupportingToken = @"Unrecognized supporting token '{0}' was encountered.";
public const string MoreThanOneSupportingSignature = @"More than one supporting signature was encountered using the same supporting token '{0}'.";
public const string UnsecuredMessageFaultReceived = @"An unsecured or incorrectly secured fault was received from the other party. See the inner FaultException for the fault code and detail.";
public const string FailedAuthenticationFaultReason = @"At least one security token in the message could not be validated.";
public const string BadContextTokenOrActionFaultReason = @"The message could not be processed. This is most likely because the action '{0}' is incorrect or because the message contains an invalid or expired security context token or because there is a mismatch between bindings. The security context token would be invalid if the service aborted the channel due to inactivity. To prevent the service from aborting idle sessions prematurely increase the Receive timeout on the service endpoint's binding.";
public const string BadContextTokenFaultReason = @"The security context token is expired or is not valid. The message was not processed.";
public const string NegotiationFailedIO = @"Transport security negotiation failed due to an underlying IO error: {0}.";
public const string SecurityNegotiationCannotProtectConfidentialEndpointHeader = @"The security negotiation with '{0}' cannot be initiated because the confidential endpoint address header ('{1}', '{2}') cannot be encrypted during the course of the negotiation.";
public const string InvalidSecurityTokenFaultReason = @"An error occurred when processing the security tokens in the message.";
public const string InvalidSecurityFaultReason = @"An error occurred when verifying security for the message.";
public const string AnonymousLogonsAreNotAllowed = @"The service does not allow you to log on anonymously.";
public const string UnableToObtainIssuerMetadata = @"Obtaining metadata from issuer '{0}' failed with error '{1}'.";
public const string ErrorImportingIssuerMetadata = @"Importing metadata from issuer '{0}' failed with error '{1}'.";
public const string MultipleCorrelationTokensFound = @"Multiple correlation tokens were found in the security correlation state.";
public const string NoCorrelationTokenFound = @"No correlation token was found in the security correlation state.";
public const string MultipleSupportingAuthenticatorsOfSameType = @"Multiple supporting token authenticators of the same type '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.";
public const string TooManyIssuedSecurityTokenParameters = @"A leg of the federated security chain contains multiple IssuedSecurityTokenParameters. The InfoCard system only supports one IssuedSecurityTokenParameters for each leg.";
public const string UnknownTokenAuthenticatorUsedInTokenProcessing = @"An unrecognized token authenticator '{0}' was used for token processing.";
public const string TokenMustBeNullWhenTokenParametersAre = @"The SecurityTokenParameters and SecurityToken tuple specified for use in the security header must both be null or must both be non-null.";
public const string SecurityTokenParametersCloneInvalidResult = @"The CloneCore method of {0} type returned an invalid result.";
public const string CertificateUnsupportedForHttpTransportCredentialOnly = @"Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.";
public const string BasicHttpMessageSecurityRequiresCertificate = @"BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.";
public const string EntropyModeRequiresRequestorEntropy = @"The client must provide key entropy in key entropy mode '{0}'.";
public const string BearerKeyTypeCannotHaveProofKey = @"A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.";
public const string BearerKeyIncompatibleWithWSFederationHttpBinding = @"Bearer Key Type is not supported with WSFederationHttpBinding. Please use WS2007FederationHttpBinding.";
public const string UnableToCreateKeyTypeElementForUnknownKeyType = @"Unable to create Key Type element for the Key Type '{0}'. This might be due to a wrong version of MessageSecurityVersion set on the SecurityBindingElement.";
public const string EntropyModeCannotHaveProofTokenOrIssuerEntropy = @"The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.";
public const string EntropyModeCannotHaveRequestorEntropy = @"The client cannot provide key entropy in key entropy mode '{0}'.";
public const string EntropyModeRequiresProofToken = @"The issuer must provide a proof token in key entropy mode '{0}'.";
public const string EntropyModeRequiresComputedKey = @"The issuer must provide a computed key in key entropy mode '{0}'.";
public const string EntropyModeRequiresIssuerEntropy = @"The issuer must provide key entropy in key entropy mode '{0}'.";
public const string EntropyModeCannotHaveComputedKey = @"The issuer cannot provide a computed key in key entropy mode '{0}'.";
public const string UnknownComputedKeyAlgorithm = @"The computed key algorithm '{0}' is not supported.";
public const string NoncesCachedInfinitely = @"The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.";
public const string ChannelMustBeOpenedToGetSessionId = @"The session channel must be opened before the session ID can be accessed.";
public const string SecurityVersionDoesNotSupportEncryptedKeyBinding = @"The binding ('{0}','{1}') for contract ('{2}','{3}') has been configured with an incompatible security version that does not support unattached references to EncryptedKeys. Use '{4}' or higher as the security version for the binding.";
public const string SecurityVersionDoesNotSupportThumbprintX509KeyIdentifierClause = @"The '{0}','{1}' binding for the '{2}','{3}' contract is configured with a security version that does not support external references to X.509 tokens using the certificate's thumbprint value. Use '{4}' or higher as the security version for the binding.";
public const string SecurityBindingSupportsOneWayOnly = @"The SecurityBinding for the ('{0}','{1}') binding for the ('{2}','{3}') contract only supports the OneWay operation.";
public const string DownlevelNameCannotMapToUpn = @"Cannot map Windows user '{0}' to a UserPrincipalName that can be used for S4U impersonation.";
public const string ResolvingExternalTokensRequireSecurityTokenParameters = @"Resolving an External reference token requires appropriate SecurityTokenParameters to be specified.";
public const string SecurityRenewFaultReason = @"The SecurityContextSecurityToken's key needs to be renewed.";
public const string ClientSecurityOutputSessionCloseTimeout = @"The client's security session was not able to close its output session within the configured timeout ({0}).";
public const string ClientSecurityNegotiationTimeout = @"Client is unable to finish the security negotiation within the configured timeout ({0}).  The current negotiation leg is {1} ({2}).";
public const string ClientSecuritySessionRequestTimeout = @"Client is unable to request the security session within the configured timeout ({0}).";
public const string ServiceSecurityCloseOutputSessionTimeout = @"The service's security session was not able to close its output session within the configured timeout ({0}).";
public const string ServiceSecurityCloseTimeout = @"The service's security session did not receive a 'close' message from the client within the configured timeout ({0}).";
public const string ClientSecurityCloseTimeout = @"The client's security session did not receive a 'close response' message from the service within the configured timeout ({0}).";
public const string UnableToRenewSessionKey = @"Cannot renew the security session key.";
public const string SctCookieXmlParseError = @"Error parsing SecurityContextSecurityToken Cookie XML.";
public const string SctCookieValueMissingOrIncorrect = @"The SecurityContextSecurityToken's Cookie element either does not contain '{0}' or has a wrong value for it.";
public const string SctCookieBlobDecodeFailure = @"Error decoding the Cookie element of SecurityContextSecurityToken.";
public const string SctCookieNotSupported = @"Issuing cookie SecurityContextSecurityToken is not supported.";
public const string CannotImportSupportingTokensForOperationWithoutRequestAction = @"Security policy import failed. The security policy contains supporting token requirements at the operation scope. The contract description does not specify the action for the request message associated with this operation.";
public const string SignatureConfirmationsNotExpected = @"Signature confirmation is not expected in the security header.";
public const string SignatureConfirmationsOccursAfterPrimarySignature = @"The signature confirmation elements cannot occur after the primary signature.";
public const string SecurityVersionDoesNotSupportSignatureConfirmation = @"The SecurityVersion '{0}' does not support signature confirmation. Use a later SecurityVersion.";
public const string SignatureConfirmationRequiresRequestReply = @"The protocol factory must support Request/Reply security in order to offer signature confirmation.";
public const string NotAllSignaturesConfirmed = @"Not all the signatures in the request message were confirmed in the reply message.";
public const string FoundUnexpectedSignatureConfirmations = @"The request did not have any signatures but the reply has signature confirmations.";
public const string TooManyPendingSessionKeys = @"There are too many renewed session keys that have not been used.";
public const string SecuritySessionKeyIsStale = @"The session key must be renewed before it can secure application messages.";
public const string MultipleMatchingCryptosFound = @"The token's crypto collection has multiple objects of type '{0}'.";
public const string CannotFindMatchingCrypto = @"The token's crypto collection does not support algorithm '{0}'.";
public const string SymmetricSecurityBindingElementNeedsProtectionTokenParameters = @"SymmetricSecurityBindingElement cannot build a channel or listener factory. The ProtectionTokenParameters property is required but not set. Binding element configuration: {0}";
public const string AsymmetricSecurityBindingElementNeedsInitiatorTokenParameters = @"AsymmetricSecurityBindingElement cannot build a channel or listener factory. The InitiatorTokenParameters property is required but not set. Binding element configuration: {0}";
public const string AsymmetricSecurityBindingElementNeedsRecipientTokenParameters = @"AsymmetricSecurityBindingElement cannot build a channel or listener factory. The RecipientTokenParameters property is required but not set. Binding element configuration: {0}";
public const string CachedNegotiationStateQuotaReached = @"The service cannot cache the negotiation state as the capacity '{0}' has been reached. Retry the request.";
public const string LsaAuthorityNotContacted = @"Internal SSL error (refer to Win32 status code for details). Check the server certificate to determine if it is capable of key exchange.";
public const string KeyRolloverGreaterThanKeyRenewal = @"The key rollover interval cannot be greater than the key renewal interval.";
public const string AtLeastOneContractOperationRequestRequiresProtectionLevelNotSupportedByBinding = @"The request message must be protected. This is required by an operation of the contract ('{0}','{1}'). The protection must be provided by the binding ('{2}','{3}').";
public const string AtLeastOneContractOperationResponseRequiresProtectionLevelNotSupportedByBinding = @"The response message must be protected. This is required by an operation of the contract ('{0}', '{1}'). The protection must be provided by the binding ('{2}', '{3}').";
public const string UnknownHeaderCannotProtected = @"The contract ('{0}','{1}') contains some unknown header ('{2}','{3}') which cannot be secured. Please choose ProtectionLevel.None for this header.";
public const string NoStreamingWithSecurity = @"The binding ('{0}','{1}') supports streaming which cannot be configured together with message level security.  Consider choosing a different transfer mode or choosing the transport level security.";
public const string CurrentSessionTokenNotRenewed = @"The supporting token in the renew message has a different generation '{0}' than the current session token's generation '{1}'.";
public const string IncorrectSpnOrUpnSpecified = @"Security Support Provider Interface (SSPI) authentication failed. The server may not be running in an account with identity '{0}'. If the server is running in a service account (Network Service for example), specify the account's ServicePrincipalName as the identity in the EndpointAddress for the server. If the server is running in a user account, specify the account's UserPrincipalName as the identity in the EndpointAddress for the server.";
public const string IncomingSigningTokenMustBeAnEncryptedKey = @"For this security protocol, the incoming signing token must be an EncryptedKey.";
public const string SecuritySessionAbortedFaultReason = @"The security session was terminated This may be because no messages were received on the session for too long.";
public const string NoAppliesToPresent = @"No AppliesTo element is present in the deserialized RequestSecurityToken/RequestSecurityTokenResponse.";
public const string UnsupportedKeyLength = @"Symmetric Key length {0} is not supported by the algorithm suite '{1}'.";
public const string ForReplayDetectionToBeDoneRequireIntegrityMustBeSet = @"For replay detection to be done ProtectionLevel must be Sign or EncryptAndSign.";
public const string CantInferReferenceForToken = @"Can't infer an external reference for '{0}' token type.";
public const string TrustApr2004DoesNotSupportCertainIssuedTokens = @"WSTrustApr2004 does not support issuing X.509 certificates or EncryptedKeys. Use WsTrustFeb2005 or above.";
public const string TrustDriverVersionDoesNotSupportSession = @"The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.";
public const string TrustDriverVersionDoesNotSupportIssuedTokens = @"The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.";
public const string CannotPerformS4UImpersonationOnPlatform = @"The binding ('{0}','{1}') for contract ('{2}','{3}') supports impersonation only on Windows 2003 Server and newer version of Windows. Use SspiNegotiated authentication and a binding with Secure Conversation with cancellation enabled.";
public const string CannotPerformImpersonationOnUsernameToken = @"Impersonation using the client token is not possible. The binding ('{0}', '{1}') for contract ('{2}', '{3}') uses the Username Security Token for client authentication with a Membership Provider registered. Use a different type of security token for the client.";
public const string SecureConversationRequiredByReliableSession = @"Cannot establish a reliable session without secure conversation. Enable secure conversation.";
public const string RevertImpersonationFailure = @"Failed to revert impersonation. {0}";
public const string TransactionFlowRequiredIssuedTokens = @"In order to flow a transaction, flowing issued tokens must also be supported.";
public const string SignatureConfirmationNotSupported = @"The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.";
public const string SecureConversationDriverVersionDoesNotSupportSession = @"The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.";
public const string SoapSecurityNegotiationFailed = @"SOAP security negotiation failed. See inner exception for more details.";
public const string SoapSecurityNegotiationFailedForIssuerAndTarget = @"SOAP security negotiation with '{0}' for target '{1}' failed. See inner exception for more details.";
public const string OneWayOperationReturnedFault = @"The one-way operation returned a fault message.  The reason for the fault was '{0}'.";
public const string OneWayOperationReturnedLargeFault = @"The one-way operation returned a fault message with Action='{0}'.";
public const string OneWayOperationReturnedMessage = @"The one-way operation returned a non-null message with Action='{0}'.";
public const string CannotFindSecuritySession = @"Cannot find the security session with the ID '{0}'.";
public const string SecurityContextKeyExpired = @"The SecurityContextSecurityToken with Context-id={0} (generation-id={1}) has expired.";
public const string SecurityContextKeyExpiredNoKeyGeneration = @"The SecurityContextSecurityToken with Context-id={0} (no key generation-id) has expired.";
public const string SecuritySessionRequiresMessageIntegrity = @"Security sessions require all messages to be signed.";
public const string RequiredTimestampMissingInSecurityHeader = @"Required timestamp missing in security header.";
public const string ReceivedMessageInRequestContextNull = @"The request message in the request context received from channel '{0}' is null.";
public const string KeyLifetimeNotWithinTokenLifetime = @"The key effective and expiration times must be bounded by the token effective and expiration times.";
public const string EffectiveGreaterThanExpiration = @"The valid from time is greater than the valid to time.";
public const string NoSessionTokenPresentInMessage = @"No session token was present in the message.";
public const string KeyLengthMustBeMultipleOfEight = @"Key length '{0}' is not a multiple of 8 for symmetric keys.";
public const string ExportOfBindingWithSymmetricAndTransportSecurityNotSupported = @"Security policy export failed. The binding contains both a SymmetricSecurityBindingElement and a secure transport binding element. Policy export for such a binding is not supported.";
public const string InvalidX509RawData = @"Invalid binary representation of an X.509 certificate.";
public const string ExportOfBindingWithAsymmetricAndTransportSecurityNotSupported = @"Security policy export failed. The binding contains both an AsymmetricSecurityBindingElement and a secure transport binding element. Policy export for such a binding is not supported.";
public const string ExportOfBindingWithTransportSecurityBindingElementAndNoTransportSecurityNotSupported = @"Security policy export failed. The binding contains a TransportSecurityBindingElement but no transport binding element that implements ITransportTokenAssertionProvider. Policy export for such a binding is not supported. Make sure the transport binding element in the binding implements the ITransportTokenAssertionProvider interface.";
public const string UnsupportedSecureConversationBootstrapProtectionRequirements = @"Cannot import the security policy. The protection requirements for the secure conversation bootstrap binding are not supported. Protection requirements for the secure conversation bootstrap must require both the request and the response to be signed and encrypted.";
public const string UnsupportedBooleanAttribute = @"Cannot import the policy. The value of the attribute '{0}' must be either 'true', 'false', '1' or '0'. The following error occurred: '{1}'.";
public const string NoTransportTokenAssertionProvided = @"The security policy expert failed. The provided transport token assertion of type '{0}' did not create a transport token assertion to include the sp:TransportBinding security policy assertion.";
public const string PolicyRequiresConfidentialityWithoutIntegrity = @"Message security policy for the '{0}' action requires confidentiality without integrity. Confidentiality without integrity is not supported.";
public const string PrimarySignatureIsRequiredToBeEncrypted = @"The primary signature must be encrypted.";
public const string TokenCannotCreateSymmetricCrypto = @"A symmetric crypto could not be created from token '{0}'.";
public const string TokenDoesNotMeetKeySizeRequirements = @"The key size requirements for the '{0}' algorithm suite are not met by the '{1}' token which has key size of '{2}'.";
public const string MessageProtectionOrderMismatch = @"The received message does not meet the required message protection order '{0}'.";
public const string PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures = @"Primary signature must be computed before supporting token signatures.";
public const string ElementToSignMustHaveId = @"Element to sign must have id.";
public const string StandardsManagerCannotWriteObject = @"The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.";
public const string SigningWithoutPrimarySignatureRequiresTimestamp = @"Signing without primary signature requires timestamp.";
public const string OperationCannotBeDoneAfterProcessingIsStarted = @"This operation cannot be done after processing is started.";
public const string MaximumPolicyRedirectionsExceeded = @"The recursive policy fetching limit has been reached. Check to determine if there is a loop in the federation service chain.";
public const string InvalidAttributeInSignedHeader = @"The ('{0}', '{1}') signed header contains the ('{2}', '{3}') attribute. The expected attribute is ('{4}', '{5}').";
public const string StsAddressNotSet = @"The address of the security token issuer is not specified. An explicit issuer address must be specified in the binding for target '{0}' or the local issuer address must be configured in the credentials.";
public const string MoreThanOneSecurityBindingElementInTheBinding = @"More than one SecurityBindingElement found in the binding ('{0}', '{1}) for contract ('{2}', '{3}'). Only one SecurityBindingElement is allowed.";
public const string ClientCredentialsUnableToCreateLocalTokenProvider = @"ClientCredentials cannot create a local token provider for token requirement {0}.";
public const string SecurityBindingElementCannotBeExpressedInConfig = @"A security policy was imported for the endpoint. The security policy contains requirements that cannot be represented in a Windows Communication Foundation configuration. Look for a comment about the SecurityBindingElement parameters that are required in the configuration file that was generated. Create the correct binding element with code. The binding configuration that is in the configuration file is not secure.";
public const string ConfigurationSchemaInsuffientForSecurityBindingElementInstance = @"The configuration schema is insufficient to describe the non-standard configuration of the following security binding element:";
public const string OperationCannotBeDoneOnReceiverSideSecurityHeaders = @"This operation cannot be done on the receiver security headers.";
public const string SecurityProtocolCannotDoReplayDetection = @"The security protocol '{0}' cannot do replay detection.";
public const string UnableToFindSecurityHeaderInMessage = @"Security processor was unable to find a security header with actor '{0}' in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.  This can occur if the service is configured for security and the client is not using security.";
public const string UnableToFindSecurityHeaderInMessageNoActor = @"Security processor was unable to find a security header in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.   This can occur if the service is configured for security and the client is not using security.";
public const string NoPrimarySignatureAvailableForSupportingTokenSignatureVerification = @"No primary signature available for supporting token signature verification.";
public const string SupportingTokenSignaturesNotExpected = @"Supporting token signatures not expected.";
public const string CannotReadToken = @"Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.";
public const string ExpectedElementMissing = @"Element '{0}' with namespace '{1}' not found.";
public const string ExpectedOneOfTwoElementsFromNamespace = @"Expected element '{0}' or element '{1}' (from namespace '{2}').";
public const string RstDirectDoesNotExpectRstr = @"AcceleratedTokenAuthenticator does not expect RequestSecurityTokenResponse from the client.";
public const string RequireNonCookieMode = @"The '{0}' binding with the '{1}' namespace is configured to issue cookie security context tokens. COM+ Integration services does not support cookie security context tokens.";
public const string RequiredSignatureMissing = @"The signature must be in the security header.";
public const string RequiredMessagePartNotSigned = @"The '{0}' required message part was not signed.";
public const string RequiredMessagePartNotSignedNs = @"The '{0}', '{1}' required message part  was not signed.";
public const string RequiredMessagePartNotEncrypted = @"The '{0}' required message part was not encrypted.";
public const string RequiredMessagePartNotEncryptedNs = @"The '{0}', '{1}' required message part  was not encrypted.";
public const string SignatureVerificationFailed = @"Signature verification failed.";
public const string CannotIssueRstTokenType = @"Cannot issue the token type '{0}'.";
public const string NoNegotiationMessageToSend = @"There is no negotiation message to send.";
public const string InvalidIssuedTokenKeySize = @"The issued token has an invalid key size '{0}'.";
public const string CannotObtainIssuedTokenKeySize = @"Cannot determine the key size of the issued token.";
public const string NegotiationIsNotCompleted = @"The negotiation has not yet completed.";
public const string NegotiationIsCompleted = @"The negotiation has already completed.";
public const string MissingMessageID = @"Request Message is missing a MessageID header. One is required to correlate a reply.";
public const string SecuritySessionLimitReached = @"Cannot create a security session. Retry later.";
public const string SecuritySessionAlreadyPending = @"The security session with id '{0}' is already pending.";
public const string SecuritySessionNotPending = @"No security session with id '{0}' is pending.";
public const string SecuritySessionListenerNotFound = @"No security session listener was found for message with action '{0}'.";
public const string SessionTokenWasNotClosed = @"The session token was not closed by the server.";
public const string ProtocolMustBeInitiator = @"'{0}' protocol can only be used by the Initiator.";
public const string ProtocolMustBeRecipient = @"'{0}' protocol can only be used at the Recipient.";
public const string SendingOutgoingmessageOnRecipient = @"Unexpected code path for server security application, sending outgoing message on Recipient.";
public const string OnlyBodyReturnValuesSupported = @"Only body return values are supported currently for protection, MessagePartDescription was specified.";
public const string UnknownTokenAttachmentMode = @"Unknown token attachment mode: {0}.";
public const string ProtocolMisMatch = @"Security protocol must be '{0}', type is: '{1}'.;";
public const string AttemptToCreateMultipleRequestContext = @"The initial request context was already specified.  Can not create two for same message.";
public const string ServerReceivedCloseMessageStateIsCreated = @"{0}.OnCloseMessageReceived when state == Created.";
public const string ShutdownRequestWasNotReceived = @"Shutdown request was not received.";
public const string UnknownFilterType = @"Unknown filter type: '{0}'.";
public const string StandardsManagerDoesNotMatch = @"Standards manager of filter does not match that of filter table.  Can not have two different filters.";
public const string FilterStrictModeDifferent = @"Session filter's isStrictMode differs from filter table's isStrictMode.";
public const string SSSSCreateAcceptor = @"SecuritySessionServerSettings.CreateAcceptor, channelAcceptor must be null, can not create twice.";
public const string TransactionFlowBadOption = @"Invalid TransactionFlowOption value.";
public const string TokenManagerCouldNotReadToken = @"Security token manager could not parse token with name '{0}', namespace '{1}', valueType '{2}'.";
public const string InvalidActionForNegotiationMessage = @"Security negotiation message has incorrect action '{0}'.";
public const string InvalidKeySizeSpecifiedInNegotiation = @"The specified key size {0} is invalid. The key size must be between {1} and {2}.";
public const string GetTokenInfoFailed = @"Could not get token information (error=0x{0:X}).";
public const string UnexpectedEndOfFile = @"Unexpected end of file.";
public const string TimeStampHasCreationAheadOfExpiry = @"The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').";
public const string TimeStampHasExpiryTimeInPast = @"The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.";
public const string TimeStampHasCreationTimeInFuture = @"The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.";
public const string TimeStampWasCreatedTooLongAgo = @"The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.";
public const string InvalidOrReplayedNonce = @"The nonce is invalid or replayed.";
public const string MessagePartSpecificationMustBeImmutable = @"Message part specification must be made constant before being set.";
public const string UnsupportedIssuerEntropyType = @"Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.";
public const string NoRequestSecurityTokenResponseElements = @"No RequestSecurityTokenResponse elements were found.";
public const string NoCookieInSct = @"The SecurityContextSecurityToken does not have a cookie.";
public const string TokenProviderReturnedBadToken = @"TokenProvider returned token of incorrect type '{0}'.";
public const string ItemNotAvailableInDeserializedRST = @"{0} is not available in deserialized RequestSecurityToken.";
public const string ItemAvailableInDeserializedRSTOnly = @"{0} is only available in a deserialized RequestSecurityToken.";
public const string ItemNotAvailableInDeserializedRSTR = @"{0} is not available in deserialized RequestSecurityTokenResponse.";
public const string ItemAvailableInDeserializedRSTROnly = @"{0} is only available in a deserialized RequestSecurityTokenResponse.";
public const string MoreThanOneRSTRInRSTRC = @"The RequestSecurityTokenResponseCollection received has more than one RequestSecurityTokenResponse element. Only one RequestSecurityTokenResponse element was expected.";
public const string Hosting_AddressIsAbsoluteUri = @"The full URI '{0}' is not allowed.  Full URIs are not allowed for the ServiceHostingEnvironment.EnsureServiceAvailable API.  Use virtual path for the corresponding service instead.";
public const string Hosting_AddressPointsOutsideTheVirtualDirectory = @"The virtual path '{0}' points outside of the virtual application '{1}'.";
public const string Hosting_AuthSchemesRequireWindowsAuth = @"Security settings for this service require Windows Authentication but it is not enabled for the IIS application that hosts this service.";
public const string Hosting_AuthSchemesRequireOtherAuth = @"Security settings for this service require '{0}' Authentication but it is not enabled for the IIS application that hosts this service.";
public const string Hosting_BadMetabaseSettingsIis7Type = @"Type '{0}' does not derive from the base type 'MetabaseSettings'.";
public const string Hosting_BaseUriDeserializedNotValid = @"The BaseUriWithWildcard object has invalid fields after deserialization.";
public const string Hosting_BuildProviderDirectiveMissing = @"The required directive '{0}' is missing.";
public const string Hosting_BuildProviderMainAttributeMissing = @"The ServiceHost directive must specify either the 'Factory' or the 'Service' attribute.";
public const string Hosting_BuildProviderDuplicateAttribute = @"The attribute '{0}' can be only specified once.";
public const string Hosting_BuildProviderDirectiveNameMissing = @"The name of the directive is missing.";
public const string Hosting_BuildProviderDirectiveEndBracketMissing = @"The ending bracket '>' for the '{0}' directive is missing in the '.svc' file.";
public const string Hosting_BuildProviderDuplicateDirective = @"The directive '{0}' can be only specified once.";
public const string Hosting_BuildProviderMutualExclusiveAttributes = @"Attributes '{0}' and '{1}' are mutually exclusive.";
public const string Hosting_BuildProviderUnknownDirective = @"The unrecognized directive '{0}' is specified.";
public const string SecureConversationNeedsBootstrapSecurity = @"Cannot create security binding element based on the configuration data. When secure conversation authentication mode is selected, the secure conversation bootstrap binding element must also be specified.";
public const string Hosting_BuildProviderRequiredAttributesMissing = @"Required attributes '{0}' and '{1}' are missing.";
public const string Hosting_BuildProviderCouldNotCreateType = @"The CLR Type '{0}' could not be loaded during service compilation. Verify that this type is either defined in a source file located in the application's \\App_Code directory, contained in a compiled assembly located in the application's \\bin directory, or present in an assembly installed in the Global Assembly Cache. Note that the type name is case-sensitive and that the directories such as \\App_Code and \\bin must be located in the application's root directory and cannot be nested in subdirectories.";
public const string Hosting_BuildProviderAttributeMissing = @"The attribute '{0}' is missing.";
public const string Hosting_BuildProviderUnknownAttribute = @"The unrecognized attribute '{0}' is specified.";
public const string Hosting_BuildProviderInvalidValueForBooleanAttribute = @"The value '{0}' of attribute '{1}' is not a valid Boolean value.";
public const string Hosting_BuildProviderInvalidValueForNonNegativeIntegerAttribute = @"The value '{0}' of attribute '{1}' is not a valid non-negative integer.";
public const string Hosting_BuildProviderAmbiguousType = @"The referenced CLR type '{0}' is ambiguous.  It is found both in assembly '{1}' and in assembly '{2}'.";
public const string Hosting_BuildProviderAttributeEmpty = @"No file is specified in the '{0}' attribute.";
public const string Hosting_ImpersonationFailed = @"An error occurred while attempting to impersonate. Execution of this request cannot continue.";
public const string Hosting_MemoryGatesCheckFailed = @"Memory gates checking failed because the free memory ({0} bytes) is less than {1}% of total memory.  As a result, the service will not be available for incoming requests.  To resolve this, either reduce the load on the machine or adjust the value of minFreeMemoryPercentageToActivateService on the serviceHostingEnvironment config element.";
public const string Hosting_GetGlobalMemoryFailed = @"Calling the API GlobalMemoryStatusEx failed.  See inner exception for more details.";
public const string Hosting_CompatibilityServiceNotHosted = @"This service requires ASP.NET compatibility and must be hosted in IIS.  Either host the service in IIS with ASP.NET compatibility turned on in web.config or set the AspNetCompatibilityRequirementsAttribute.AspNetCompatibilityRequirementsMode property to a value other than Required.";
public const string Hosting_CompilationResultEmpty = @"Compilation result for the service '{0}' is empty.";
public const string Hosting_CompilationResultInvalid = @"Compilation result for the service '{0}' is of invalid format.";
public const string Hosting_EnvironmentShuttingDown = @"Request to the service at '{0}' cannot be dispatched because the virtual application at '{1}' is shutting down.";
public const string Hosting_ListenerNotFoundForActivation = @"There was no channel actively listening at '{0}'. This is often caused by an incorrect address URI. Ensure that the address to which the message is sent matches an address on which a service is listening.";
public const string Hosting_ListenerNotFoundForActivationInRecycling = @"There was no channel actively listening at '{0}'. This might be because the service is closed due to application recycling.";
public const string Hosting_MetabaseAccessError = @"An error occurred while accessing the IIS Metabase.";
public const string Hosting_MetabaseDataStringsTerminate = @"The string array data for the property '{0}' retrieved from IIS Metabase has invalid length or is not null terminated.";
public const string Hosting_MetabaseDataTypeUnsupported = @"The data type '{0}' is not supported for the property '{1}' in IIS Metabase.";
public const string Hosting_MetabaseSettingsIis7TypeNotFound = @"Type '{0}' cannot be found in the assembly '{1}'.";
public const string Hosting_MisformattedPort = @"The '{0}' protocol binding '{1}' specifies an invalid port number '{2}'.";
public const string Hosting_MisformattedBinding = @"The protocol binding '{0}' does not conform to the syntax for '{1}'. The following is an example of valid '{1}' protocol bindings: '{2}'.";
public const string Hosting_MisformattedBindingData = @"The protocol binding '{0}' is not valid for '{1}'.  This might be because the port number is out of range.";
public const string Hosting_NonHTTPInCompatibilityMode = @"Protocols other than HTTP/HTTPS are not supported under ASP.NET compatibility. Remove the endpoint '{0}' or disable ASP.NET compatibility for the application.";
public const string Hosting_NoHttpTransportManagerForUri = @"There is no compatible TransportManager found for URI '{0}'. This may be because that you have used an absolute address which points outside of the virtual application. Please use a relative address instead.";
public const string Hosting_NoTcpPipeTransportManagerForUri = @"There is no compatible TransportManager found for URI '{0}'. This may be because that you have used an absolute address which points outside of the virtual application, or the binding settings of the endpoint do not match those that have been set by other services or endpoints. Note that all bindings for the same protocol should have same settings in the same application.";
public const string Hosting_NotSupportedAuthScheme = @"The authentication scheme '{0}' is not supported.";
public const string Hosting_NotSupportedProtocol = @"The protocol '{0}' is not supported.";
public const string Hosting_ProcessNotExecutingUnderHostedContext = @"'{0}' cannot be invoked within the current hosting environment. This API requires that the calling application be hosted in IIS or WAS.";
public const string Hosting_ProtocolNoConfiguration = @"The protocol '{0}' does not have an implementation of HostedTransportConfiguration type registered.";
public const string Hosting_ServiceActivationFailed = @"The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.";
public const string Hosting_ServiceCompatibilityNotAllowed = @"The service cannot be activated because it does not support ASP.NET compatibility. ASP.NET compatibility is enabled for this application. Turn off ASP.NET compatibility mode in the web.config or add the AspNetCompatibilityRequirements attribute to the service type with RequirementsMode setting as 'Allowed' or 'Required'.";
public const string Hosting_ServiceCompatibilityRequire = @"The service cannot be activated because it requires ASP.NET compatibility. ASP.NET compatibility is not enabled for this application. Either enable ASP.NET compatibility in web.config or set the AspNetCompatibilityRequirementsAttribute.AspNetCompatibilityRequirementsMode property to a value other than Required.";
public const string Hosting_ServiceNotExist = @"The service '{0}' does not exist.";
public const string Hosting_SslSettingsMisconfigured = @"The SSL settings for the service '{0}' does not match those of the IIS '{1}'.";
public const string Hosting_TransportBindingNotFound = @"No protocol binding matches the given address '{0}'. Protocol bindings are configured at the Site level in IIS or WAS configuration.";
public const string Hosting_IServiceHostNotImplemented = @"The CLR type '{0}', provided as the Factory attribute of the ServiceHost directive in the '.svc' file, does not derive from ServiceHostFactoryBase.";
public const string Hosting_NoDefaultCtor = @"The type {0} provided as the Factory attribute value in the ServiceHost directive does not implement a default constructor.";
public const string Hosting_ServiceTypeNotProvided = @"The value for the Service attribute was not provided in the ServiceHost directive.";
public const string Hosting_ServiceTypeNotResolved = @"The type '{0}', provided as the Service attribute value in the ServiceHost directive could not be found.";
public const string Hosting_ServiceHostBaseIsNull = @"The ServiceHostBase object returned from the CreateServiceHost method of type '{0}' is null.";
public const string Hosting_ServiceCannotBeActivated = @"The service '{0}' cannot be activated due to an exception during compilation.  The exception message is: {1}.";
public const string Hosting_VirtualPathExtenstionCanNotBeDetached = @"VirtualPathExtension is not allowed to be removed.";
public const string SharedEndpointReadDenied = @"The service endpoint failed to listen on the URI '{0}' because access was denied.  Verify that the current user is granted access in the appropriate allowedAccounts section of SMSvcHost.exe.config.";
public const string SharedEndpointReadNotFound = @"The service endpoint failed to listen on the URI '{0}' because the shared memory section was not found.  Verify that the '{1}' service is running.";
public const string SharedManagerBase = @"The TransportManager failed to listen on the supplied URI using the {0} service: {1}.";
public const string SharedManagerServiceStartFailure = @"failed to start the service ({0}). Refer to the Event Log for more details";
public const string SharedManagerServiceStartFailureDisabled = @"failed to start the service because it is disabled. An administrator can enable it by running 'sc.exe config {0} start= demand'.";
public const string SharedManagerServiceStartFailureNoError = @"failed to start the service. Refer to the Event Log for more details";
public const string SharedManagerServiceLookupFailure = @"failed to look up the service process in the SCM ({0})";
public const string SharedManagerServiceSidLookupFailure = @"failed to look up the service SID in the SCM ({0})";
public const string SharedManagerServiceEndpointReadFailure = @"failed to read the service's endpoint with native error code {0}.  See inner exception for details";
public const string SharedManagerServiceSecurityFailed = @"the service failed the security checks";
public const string SharedManagerUserSidLookupFailure = @"failed to retrieve the UserSid of the service process ({0})";
public const string SharedManagerCurrentUserSidLookupFailure = @"failed to retrieve the UserSid of the current process";
public const string SharedManagerLogonSidLookupFailure = @"failed to retrieve the LogonSid of the service process ({0})";
public const string SharedManagerDataConnectionFailure = @"failed to establish a data connection to the service";
public const string SharedManagerDataConnectionCreateFailure = @"failed to create a data connection to the service";
public const string SharedManagerDataConnectionTimeout = @"failed to establish the data connection to the service because of a timeout";
public const string SharedManagerDataConnectionPipeFailed = @"failed to establish the data connection because of an I/O error";
public const string SharedManagerVersionUnsupported = @"the version is not supported by the service";
public const string SharedManagerAllowDupHandleFailed = @"failed to grant the PROCESS_DUP_HANDLE access right to the target service's account SID '{0}'.";
public const string SharedManagerPathTooLong = @"the URI is too long";
public const string SharedManagerRegistrationQuotaExceeded = @"the quota was exceeded";
public const string SharedManagerProtocolUnsupported = @"the protocol is not supported";
public const string SharedManagerConflictingRegistration = @"the URI is already registered with the service";
public const string SharedManagerFailedToListen = @"the service failed to listen";
public const string Sharing_ConnectionDispatchFailed = @"The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details";
public const string Sharing_EndpointUnavailable = @"The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.";
public const string Sharing_EmptyListenerEndpoint = @"The endpoint address for the NT service '{0}' read from shared memory is empty.";
public const string Sharing_ListenerProxyStopped = @"The message could not be dispatched because the transport manager has been stopped.  This can happen if the application is being recycled or disabled.";
public const string UnexpectedEmptyElementExpectingClaim = @"The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim.";
public const string UnexpectedElementExpectingElement = @"'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'";
public const string UnexpectedDuplicateElement = @"'{0}' from namespace '{1}' is not expected to appear more than once";
public const string UnsupportedSecurityPolicyAssertion = @"An unsupported security policy assertion was detected during the security policy import: {0}";
public const string MultipleIdentities = @"The extensions cannot contain an Identity if one is supplied as a constructor argument.";
public const string InvalidUriValue = @"Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.";
public const string InvalidLockOperationStack = @"Object synchronization method was called from an unsynchronized block of code. Previous Exit(): {0}";
public const string InvalidLockOperation = @"Object synchronization method was called from an unsynchronized block of code.";
public const string BindingDoesNotSupportProtectionForRst = @"The binding ('{0}','{1}') for contract ('{2}','{3}') is configured with SecureConversation, but the authentication mode is not able to provide the request/reply-based integrity and confidentiality required for the negotiation.";
public const string TransportDoesNotProtectMessage = @"The '{0}'.'{1}' binding is configured with an authentication mode that requires transport level integrity and confidentiality. However the transport cannot provide integrity and confidentiality.";
public const string BindingDoesNotSupportWindowsIdenityForImpersonation = @"The contract operation '{0}' requires Windows identity for automatic impersonation. A Windows identity that represents the caller is not provided by binding ('{1}','{2}') for contract ('{3}','{4}'.";
public const string ListenUriNotSet = @"A listen URI must be specified in order to open this {0}.";
public const string UnsupportedChannelInterfaceType = @"Channel interface type '{0}' is not supported.";
public const string TransportManagerOpen = @"This property cannot be changed after the transport manager has been opened.";
public const string TransportManagerNotOpen = @"This operation is only valid after the transport manager has been opened.";
public const string UnrecognizedIdentityType = @"Unrecognized identity type Name='{0}', Namespace='{1}'.";
public const string InvalidIdentityElement = @"Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.";
public const string UnableToLoadCertificateIdentity = @"Cannot load the X.509 certificate identity specified in the configuration.";
public const string UnrecognizedClaimTypeForIdentity = @"The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.";
public const string AsyncCallbackException = @"An AsyncCallback threw an exception.";
public const string SendCannotBeCalledAfterCloseOutputSession = @"You cannot Send messages on a channel after CloseOutputSession has been called.";
public const string CommunicationObjectCannotBeModifiedInState = @"The communication object, {0}, cannot be modified while it is in the {1} state.";
public const string CommunicationObjectCannotBeModified = @"The communication object, {0}, cannot be modified unless it is in the Created state.";
public const string CommunicationObjectCannotBeUsed = @"The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.";
public const string CommunicationObjectFaulted1 = @"The communication object, {0}, cannot be used for communication because it is in the Faulted state.";
public const string CommunicationObjectFaultedStack2 = @"The communication object, {0}, cannot be used for communication because it is in the Faulted state: {1}";
public const string CommunicationObjectAborted1 = @"The communication object, {0}, cannot be used for communication because it has been Aborted.";
public const string CommunicationObjectAbortedStack2 = @"The communication object, {0}, cannot be used for communication because it has been Aborted: {1}";
public const string CommunicationObjectBaseClassMethodNotCalled = @"The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.";
public const string CommunicationObjectInInvalidState = @"The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.";
public const string ChannelFactoryCannotBeUsedToCreateChannels = @"A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.";
public const string ChannelParametersCannotBeModified = @"Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.";
public const string ChannelParametersCannotBePropagated = @"Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.";
public const string OneWayInternalTypeNotSupported = @"Binding '{0}' is not configured properly. OneWayBindingElement requires an inner binding element that supports IRequestChannel/IReplyChannel or IDuplexSessionChannel.";
public const string ChannelTypeNotSupported = @"The specified channel type {0} is not supported by this channel manager.";
public const string SecurityContextMissing = @"SecurityContext for the UltimateReceiver role is missing from the SecurityContextProperty of the request message with action '{0}'.";
public const string SecurityContextDoesNotAllowImpersonation = @"Cannot start impersonation because the SecurityContext for the UltimateReceiver role from the request message with the '{0}' action is not mapped to a Windows identity.";
public const string InvalidEnumValue = @"Unexpected internal enum value: {0}.";
public const string InvalidDecoderStateMachine = @"Invalid decoder state machine.";
public const string OperationPropertyIsRequiredForAttributeGeneration = @"Operation property of OperationAttributeGenerationContext is required to generate an attribute based on settings.";
public const string InvalidMembershipProviderSpecifiedInConfig = @"The username/password Membership provider {0} specified in the configuration is invalid. No such provider was found registered under system.web/membership/providers.";
public const string InvalidRoleProviderSpecifiedInConfig = @"The RoleProvider {0} specified in the configuration is invalid. No such provider was found registered under system.web/roleManager/providers.";
public const string ObjectDisposed = @"The {0} object has been disposed.";
public const string InvalidReaderPositionOnCreateMessage = @"The XmlReader used for the body of the message must be positioned on an element.";
public const string DuplicateMessageProperty = @"A property with the name '{0}' already exists.";
public const string MessagePropertyNotFound = @"A property with the name '{0}' is not present.";
public const string HeaderAlreadyUnderstood = @"The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.";
public const string HeaderAlreadyNotUnderstood = @"The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.";
public const string MultipleMessageHeaders = @"Multiple headers with name '{0}' and namespace '{1}' found.";
public const string MultipleMessageHeadersWithActor = @"Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.";
public const string MultipleRelatesToHeaders = @" Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.";
public const string ExtraContentIsPresentInFaultDetail = @"Additional XML content is present in the fault detail element. Only a single element is allowed.";
public const string MessageIsEmpty = @"The body of the message cannot be read because it is empty.";
public const string MessageClosed = @"Message is closed.";
public const string BodyWriterReturnedIsNotBuffered = @"The body writer returned from OnCreateBufferedCopy was not buffered.";
public const string BodyWriterCanOnlyBeWrittenOnce = @"The body writer does not support writing more than once because it is not buffered.";
public const string RstrKeySizeNotProvided = @"KeySize element not present in RequestSecurityTokenResponse.";
public const string RequestMessageDoesNotHaveAMessageID = @"A reply message cannot be created because the request message does not have a MessageID.";
public const string HeaderNotFound = @"There is not a header with name {0} and namespace {1} in the message.";
public const string BufferIsNotRightSizeForBufferManager = @"This buffer cannot be returned to the buffer manager because it is the wrong size.";
public const string MessageBufferIsClosed = @"MessageBuffer is closed.";
public const string MessageTextEncodingNotSupported = @"The text encoding '{0}' used in the text message format is not supported.";
public const string AtLeastOneFaultReasonMustBeSpecified = @"At least one fault reason must be specified.";
public const string NoNullTranslations = @"The translation set cannot contain nulls.";
public const string FaultDoesNotHaveAnyDetail = @"The fault does not have detail information.";
public const string InvalidXmlQualifiedName = @"Expected XML qualified name, found '{0}'.";
public const string UnboundPrefixInQName = @"Unbound prefix used in qualified name '{0}'.";
public const string MessageBodyToStringError = @"... Error reading body: {0}: {1} ...";
public const string NoMatchingTranslationFoundForFaultText = @"The fault reason does not contain any text translations.";
public const string CannotDetermineSPNBasedOnAddress = @"Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\\alice) or SPN identity (like host/bobs-machine).";
public const string XmlLangAttributeMissing = @"Required xml:lang attribute value is missing.";
public const string EncoderUnrecognizedCharSet = @"Unrecognized charSet '{0}' in contentType.";
public const string EncoderUnrecognizedContentType = @"Unrecognized contentType ({0}). Expected: {1}.";
public const string EncoderBadContentType = @"Cannot process contentType.";
public const string EncoderEnvelopeVersionMismatch = @"The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.";
public const string EncoderMessageVersionMismatch = @"The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.";
public const string MtomEncoderBadMessageVersion = @"MessageVersion '{0}' not supported by MTOM encoder.";
public const string ReadNotSupported = @"Read is not supported on this stream.";
public const string SeekNotSupported = @"Seek is not supported on this stream.";
public const string ChannelInitializationTimeout = @"A newly accepted connection did not receive initialization data from the sender within the configured ChannelInitializationTimeout ({0}).  As a result, the connection will be aborted.  If you are on a highly congested network, or your sending machine is heavily loaded, consider increasing this value or load-balancing your server.";
public const string SocketCloseReadTimeout = @"The remote endpoint of the socket ({0}) did not respond to a close request within the allotted timeout ({1}). It is likely that the remote endpoint is not calling Close after receiving the EOF signal (null) from Receive. The time allotted to this operation may have been a portion of a longer timeout.";
public const string SocketCloseReadReceivedData = @"A graceful close was attempted on the socket, but the other side ({0}) is still sending data.";
public const string PipeCantCloseWithPendingWrite = @"The pipe cannot be closed while a write to the pipe is pending.";
public const string PipeShutdownWriteError = @"The shutdown indicator could not be written to the pipe.  The application on the other end of the pipe may not be listening for it.  The pipe will still be closed.";
public const string PipeShutdownReadError = @"The shutdown indicator was not received from the pipe.  The application on the other end of the pipe may not have sent it.  The pipe will still be closed.";
public const string PipeNameCanNotBeAccessed = @"The pipe name could not be obtained for the pipe URI: {0}";
public const string PipeNameCanNotBeAccessed2 = @"The pipe name could not be obtained for {0}.";
public const string PipeModeChangeFailed = @"The pipe was not able to be set to message mode: {0}";
public const string PipeCloseFailed = @"The pipe could not close gracefully.  This may be caused by the application on the other end of the pipe exiting.";
public const string PipeAlreadyShuttingDown = @"The pipe cannot be written to because it is already in the process of shutting down.";
public const string PipeSignalExpected = @"The read from the pipe expected just a signal, but received actual data.";
public const string PipeAlreadyClosing = @"The pipe cannot be written to or read from because it is already in the process of being closed.";
public const string PipeAcceptFailed = @"Server cannot accept pipe: {0}";
public const string PipeListenFailed = @"Cannot listen on pipe '{0}': {1}";
public const string PipeNameInUse = @"Cannot listen on pipe name '{0}' because another pipe endpoint is already listening on that name.";
public const string PipeNameCantBeReserved = @"Cannot listen on pipe '{0}' because the pipe name could not be reserved: {1}";
public const string PipeListenerDisposed = @"The pipe listener has been disposed.";
public const string PipeListenerNotListening = @"Connections cannot be created until the pipe has started listening.  Call Listen() before attempting to accept a connection.";
public const string PipeConnectAddressFailed = @"A pipe endpoint exists for '{0}', but the connect failed: {1}";
public const string PipeConnectFailed = @"Cannot connect to endpoint '{0}'.";
public const string PipeConnectTimedOut = @"Cannot connect to endpoint '{0}' within the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string PipeConnectTimedOutServerTooBusy = @"Cannot connect to endpoint '{0}' within the allotted timeout of {1}. The server has likely reached the MaxConnections quota and is too busy to accept new connections. The time allotted to this operation may have been a portion of a longer timeout.";
public const string PipeEndpointNotFound = @"The pipe endpoint '{0}' could not be found on your local machine.";
public const string PipeUriSchemeWrong = @"URIs used with pipes must use the scheme: 'net.pipe'.";
public const string PipeWriteIncomplete = @"The pipe write did not write all the bytes.";
public const string PipeClosed = @"The operation cannot be completed because the pipe was closed.  This may have been caused by the application on the other end of the pipe exiting.";
public const string PipeReadTimedOut = @"The read from the pipe did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string PipeWriteTimedOut = @"The write to the pipe did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string PipeConnectionAbortedReadTimedOut = @"The pipe connection was aborted because an asynchronous read from the pipe did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string PipeConnectionAbortedWriteTimedOut = @"The pipe connection was aborted because an asynchronous write to the pipe did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string PipeWriteError = @"There was an error writing to the pipe: {0}.";
public const string PipeReadError = @"There was an error reading from the pipe: {0}.";
public const string PipeUnknownWin32Error = @"Unrecognized error {0} (0x{1})";
public const string PipeKnownWin32Error = @"{0} ({1}, 0x{2})";
public const string PipeWritePending = @"There is already a write in progress for the pipe.  Wait for the first operation to complete before attempting to write again.";
public const string PipeReadPending = @"There is already a read in progress for the pipe.  Wait for the first operation to complete before attempting to read again.";
public const string PipeDuplicationFailed = @"There was an error duplicating the.";
public const string SocketAbortedReceiveTimedOut = @"The socket was aborted because an asynchronous receive from the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string SocketAbortedSendTimedOut = @"The socket connection was aborted because an asynchronous send to the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string ThreadAcquisitionTimedOut = @"Cannot claim lock within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string OperationInvalidBeforeSecurityNegotiation = @"This operation is not valid until security negotiation is complete.";
public const string FramingError = @"Error while reading message framing format at position {0} of stream (state: {1})";
public const string FramingPrematureEOF = @"More data was expected, but EOF was reached.";
public const string FramingRecordTypeMismatch = @"Expected record type '{0}', found '{1}'.";
public const string FramingVersionNotSupported = @"Framing major version {0} is not supported.";
public const string FramingModeNotSupported = @"Framing mode {0} is not supported.";
public const string FramingSizeTooLarge = @"Specified size is too large for this implementation.";
public const string FramingViaTooLong = @"The framing via size ({0}) exceeds the quota.";
public const string FramingViaNotUri = @"The framing via ({0}) is not a valid URI.";
public const string FramingFaultTooLong = @"The framing fault size ({0}) exceeds the quota.";
public const string FramingContentTypeTooLong = @"The framing content type size ({0}) exceeds the quota.";
public const string FramingValueNotAvailable = @"The value cannot be accessed because it has not yet been fully decoded.";
public const string FramingAtEnd = @"An attempt was made to decode a value after the framing stream was ended.";
public const string RemoteSecurityNotNegotiatedOnStreamUpgrade = @"Stream Security is required at {0}, but no security context was negotiated. This is likely caused by the remote endpoint missing a StreamSecurityBindingElement from its binding.";
public const string BinaryEncoderSessionTooLarge = @"The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.";
public const string BinaryEncoderSessionInvalid = @"The binary encoder session is not valid. There was an error decoding a previous message.";
public const string BinaryEncoderSessionMalformed = @"The binary encoder session information is not properly formed.";
public const string ReceiveShutdownReturnedFault = @"The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'";
public const string ReceiveShutdownReturnedLargeFault = @"The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.";
public const string ReceiveShutdownReturnedMessage = @"The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.";
public const string MaxReceivedMessageSizeExceeded = @"The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.";
public const string MaxSentMessageSizeExceeded = @"The maximum message size quota for outgoing messages ({0}) has been exceeded.";
public const string FramingMaxMessageSizeExceeded = @"The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.";
public const string StreamDoesNotSupportTimeout = @"TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.";
public const string FilterExists = @"The filter already exists in the filter table.";
public const string FilterUnexpectedError = @"An internal error has occurred. Unexpected error modifying filter table.";
public const string FilterNodeQuotaExceeded = @"The number of XML infoset nodes inspected by the navigator has exceeded the quota ({0}).";
public const string FilterCapacityNegative = @"Value cannot be negative.";
public const string ActionFilterEmptyList = @"The set of actions cannot be empty.";
public const string FilterUndefinedPrefix = @"The prefix '{0}' is not defined.";
public const string FilterMultipleMatches = @"Multiple filters matched.";
public const string FilterTableTypeMismatch = @"The type of IMessageFilterTable created for a particular Filter type must always be the same.";
public const string FilterTableInvalidForLookup = @"The MessageFilterTable state is corrupt. The requested lookup cannot be performed.";
public const string FilterBadTableType = @"The IMessageFilterTable created for a Filter cannot be a MessageFilterTable or a subclass of MessageFilterTable.";
public const string FilterQuotaRange = @"NodeQuota must be greater than 0.";
public const string FilterEmptyString = @"Parameter value cannot be an empty string.";
public const string FilterInvalidInner = @"Required inner element '{0}' was not found.";
public const string FilterInvalidAttribute = @"Invalid attribute on the XPath.";
public const string FilterInvalidDialect = @"When present, the dialect attribute must have the value '{0}'.";
public const string FilterCouldNotCompile = @"Could not compile the XPath expression '{0}' with the given XsltContext.";
public const string FilterReaderNotStartElem = @"XmlReader not positioned at a start element.";
public const string SeekableMessageNavInvalidPosition = @"The position is not valid for this navigator.";
public const string SeekableMessageNavNonAtomized = @"Cannot call '{0}' on a non-atomized navigator.";
public const string SeekableMessageNavIDNotSupported = @"XML unique ID not supported.";
public const string SeekableMessageNavBodyForbidden = @"A filter has attempted to access the body of a Message. Use a MessageBuffer instead if body filtering is required.";
public const string SeekableMessageNavOverrideForbidden = @"Not allowed to override prefix '{0}'.";
public const string QueryNotImplemented = @"The function '{0}' is not implemented.";
public const string QueryNotSortable = @"XPathNavigator positions cannot be compared.";
public const string QueryMustBeSeekable = @"XPathNavigator must be a SeekableXPathNavigator.";
public const string QueryContextNotSupportedInSequences = @"Context node is not supported in node sequences.";
public const string QueryFunctionTypeNotSupported = @"IXsltContextFunction return type '{0}' not supported.";
public const string QueryVariableTypeNotSupported = @"IXsltContextVariable type '{0}' not supported.";
public const string QueryVariableNull = @"IXsltContextVariables cannot return null.";
public const string QueryFunctionStringArg = @"The argument to an IXsltContextFunction could not be converted to a string.";
public const string QueryItemAlreadyExists = @"An internal error has occurred. Item already exists.";
public const string QueryBeforeNodes = @"Positioned before first element.";
public const string QueryAfterNodes = @"Positioned after last element.";
public const string QueryIteratorOutOfScope = @"The XPathNodeIterator has been invalidated. XPathNodeIterators passed as arguments to IXsltContextFunctions are only valid within the function. They cannot be cached for later use or returned as the result of the function.";
public const string AddressingVersionNotSupported = @"Addressing Version '{0}' is not supported.";
public const string SupportedAddressingModeNotSupported = @"The '{0}' addressing mode is not supported.";
public const string MessagePropertyReturnedNullCopy = @"The IMessageProperty could not be copied. CreateCopy returned null.";
public const string MessageVersionUnknown = @"Unrecognized message version.";
public const string EnvelopeVersionUnknown = @"Unrecognized envelope version: {0}.";
public const string EnvelopeVersionNotSupported = @"Envelope Version '{0}' is not supported.";
public const string CannotDetectAddressingVersion = @"Cannot detect WS-Addressing version. EndpointReference does not start with an Element.";
public const string HeadersCannotBeAddedToEnvelopeVersion = @"Envelope Version '{0}' does not support adding Message Headers.";
public const string AddressingHeadersCannotBeAddedToAddressingVersion = @"Addressing Version '{0}' does not support adding WS-Addressing headers.";
public const string AddressingExtensionInBadNS = @"The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.";
public const string MessageHeaderVersionNotSupported = @"The '{0}' header cannot be added because it does not support the specified message version '{1}'.";
public const string MessageHasBeenCopied = @"This message cannot support the operation because it has been copied.";
public const string MessageHasBeenWritten = @"This message cannot support the operation because it has been written.";
public const string MessageHasBeenRead = @"This message cannot support the operation because it has been read.";
public const string InvalidMessageState = @"An internal error has occurred. Invalid MessageState.";
public const string MessageBodyReaderInvalidReadState = @"The body reader is in ReadState '{0}' and cannot be consumed.";
public const string XmlBufferQuotaExceeded = @"The size necessary to buffer the XML content exceeded the buffer quota.";
public const string XmlBufferInInvalidState = @"An internal error has occurred. The XML buffer is not in the correct state to perform the operation.";
public const string GetComputerNameReturnedInvalidLenth = @"GetComputerName returned an invalid length: {0}.";
public const string MessageBodyMissing = @"A body element was not found inside the message envelope.";
public const string MessageHeaderVersionMismatch = @"The version of the header(s) ({0}) differs from the version of the message ({1}).";
public const string ManualAddressingRequiresAddressedMessages = @"Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.";
public const string OneWayHeaderNotFound = @"A one-way header was expected on this message and none was found. It is possible that your bindings are mismatched.";
public const string ReceiveTimedOut = @"Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string ReceiveTimedOut2 = @"Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string WaitForMessageTimedOut = @"WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string ReceiveTimedOutNoLocalAddress = @"Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string ReceiveRequestTimedOutNoLocalAddress = @"Receive request timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string ReceiveRequestTimedOut = @"Receive request on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string SendToViaTimedOut = @"Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string CloseTimedOut = @"Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.";
public const string OpenTimedOutEstablishingTransportSession = @"Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string RequestTimedOutEstablishingTransportSession = @"Request timed out after {0} while establishing a transport connection to {1}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string TcpConnectingToViaTimedOut = @"Connecting to via {0} timed out after {1}. Connection attempts were made to {2} of {3} available addresses ({4}). Check the RemoteAddress of your channel and verify that the DNS records for this endpoint correspond to valid IP Addresses. The time allotted to this operation may have been a portion of a longer timeout.";
public const string RequestChannelSendTimedOut = @"The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.";
public const string RequestChannelWaitForReplyTimedOut = @"The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.";

public const string HttpConcurrentReceiveQuotaReached = @"The HTTP concurrent receive quota was reached. The quota is {0}.";

public const string HttpTransportCannotHaveMultipleAuthenticationSchemes = @"The policy being imported for contract '{0}:{1}' contains multiple HTTP authentication scheme assertions.  Since at most one such assertion is allowed, policy import has failed.  This may be resolved by updating the policy to contain no more than one HTTP authentication scheme assertion.";
public const string HttpIfModifiedSinceParseError = @"The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.";
public const string HttpSoapActionMismatch = @"The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.";
public const string HttpSoapActionMismatchContentType = @"The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.";
public const string HttpSoapActionMismatchFault = @"The SOAP action specified on the message, '{0}', does not match the HTTP SOAP Action, '{1}'.";
public const string HttpContentTypeFormatException = @"An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.";
public const string HttpServerTooBusy = @"The HTTP service located at {0} is too busy.";
public const string HttpRequestAborted = @"The HTTP request to '{0}' was aborted.  This may be due to the local channel being closed while the request was still in progress.  If this behavior is not desired, then update your code so that it does not close the channel while request operations are still in progress.";
public const string HttpRequestTimedOut = @"The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string HttpRequestTimedOutWithoutDetail = @"The HTTP request to '{0}' has exceeded the allotted timeout. The time allotted to this operation may have been a portion of a longer timeout.";
public const string HttpResponseTimedOut = @"The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.";
public const string HttpTransferError = @"An error ({0}) occurred while transmitting data over the HTTP channel.";
public const string HttpReceiveFailure = @"An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.";
public const string HttpSendFailure = @"An error occurred while making the HTTP request to {0}. This could be due to the fact that the server certificate is not configured properly with HTTP.SYS in the HTTPS case. This could also be caused by a mismatch of the security binding between the client and the server.";
public const string HttpAuthDoesNotSupportRequestStreaming = @"HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.";
public const string ReplyAlreadySent = @"A reply has already been sent from this RequestContext.";
public const string HttpInvalidListenURI = @"Unable to start the HTTP listener. The URI provided, '{0}', is invalid for listening. Check the base address of your service and verify that it is a valid URI.";
public const string RequestContextAborted = @"The requestContext has been aborted.";
public const string ThreadNeutralSemaphoreAborted = @"The ThreadNeutralSemaphore has been aborted.";
public const string ThreadNeutralSemaphoreAsyncAbort = @"The ThreadNeutralSemaphore.Abort is not supported for the asynchronous usage.";
public const string UnrecognizedHostNameComparisonMode = @"Invalid HostNameComparisonMode value: {0}.";
public const string BadData = @"Invalid data buffer.";
public const string InvalidRenewResponseAction = @"A security session renew response was received with an invalid action '{0}'.";
public const string InvalidCloseResponseAction = @"A security session close response was received with an invalid action '{0}',";
public const string NullSessionRequestMessage = @"Could not formulate request message for security session operation '{0}'.";
public const string IssueSessionTokenHandlerNotSet = @"There is no handler registered for session token issuance event.";
public const string RenewSessionTokenHandlerNotSet = @"There is no handler registered for session token renew event.";
public const string WrongIdentityRenewingToken = @"The identity of the security session renew message does not match the identity of the session token.";
public const string InvalidRstRequestType = @"The RequestSecurityToken has an invalid or unspecified RequestType '{0}'.";
public const string NoCloseTargetSpecified = @"The RequestSecurityToken must specify a CloseTarget.";
public const string FailedSspiNegotiation = @"Secure channel cannot be opened because security negotiation with the remote endpoint has failed. This may be due to absent or incorrectly specified EndpointIdentity in the EndpointAddress used to create the channel. Please verify the EndpointIdentity specified or implied by the EndpointAddress correctly identifies the remote endpoint.";
public const string BadCloseTarget = @"The CloseTarget specified '{0}' does not identify the security token that signed the message.";
public const string RenewSessionMissingSupportingToken = @"The renew security session message does not have the session token as a supporting token.";
public const string NoRenewTargetSpecified = @"The RequestSecurityToken must specify a RenewTarget.";
public const string BadRenewTarget = @"There is no endorsing session token that matches the specified RenewTarget '{0}'.";
public const string ReferenceListCannotBeEmpty = @"The ReferenceList element must have at least one DataReference or KeyReference.";
public const string BadEncryptedBody = @"Invalid format for encrypted body.";
public const string BadEncryptionState = @"The EncryptedData or EncryptedKey is in an invalid state for this operation.";
public const string NoSignaturePartsSpecified = @"No signature message parts were specified for messages with the '{0}' action.";
public const string NoEncryptionPartsSpecified = @"No encryption message parts were specified for messages with the '{0}' action.";
public const string SecuritySessionFaultReplyWasSent = @"The receiver sent back a security session fault message. Retry the request.";
public const string InnerListenerFactoryNotSet = @"The Inner listener factory of {0} must be set before this operation.";
public const string SecureConversationBootstrapCannotUseSecureConversation = @"Cannot create security binding element based on configuration data. The secure conversation bootstrap requires another secure conversation which is not supported.";
public const string InnerChannelFactoryWasNotSet = @"Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.";
public const string SecurityProtocolFactoryDoesNotSupportDuplex = @"Duplex security is not supported by the security protocol factory '{0}'.";
public const string SecurityProtocolFactoryDoesNotSupportRequestReply = @"Request-reply security is not supported by the security protocol factory '{0}'.";
public const string SecurityProtocolFactoryShouldBeSetBeforeThisOperation = @"The security protocol factory must be set before this operation is performed.";
public const string SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation = @"Security session protocol factory must be set before this operation is performed.";
public const string SecureConversationSecurityTokenParametersRequireBootstrapBinding = @"Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.";
public const string PropertySettingErrorOnProtocolFactory = @"The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.";
public const string ProtocolFactoryCouldNotCreateProtocol = @"The protocol factory cannot create a protocol.";
public const string IdentityCheckFailedForOutgoingMessage = @"The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.";
public const string IdentityCheckFailedForIncomingMessage = @"The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.";
public const string DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim = @"The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.";
public const string DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim = @"The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.";
public const string DnsIdentityCheckFailedForIncomingMessage = @"Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy.";
public const string DnsIdentityCheckFailedForOutgoingMessage = @"Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy.";
public const string SerializedTokenVersionUnsupported = @"The serialized token version {0} is unsupported.";
public const string AuthenticatorNotPresentInRSTRCollection = @"The RequestSecurityTokenResponseCollection does not contain an authenticator.";
public const string RSTRAuthenticatorHasBadContext = @"The negotiation RequestSecurityTokenResponse has a different context from the authenticator RequestSecurityTokenResponse.";
public const string ServerCertificateNotProvided = @"The recipient did not provide its certificate.  This certificate is required by the TLS protocol.  Both parties must have access to their certificates.";
public const string RSTRAuthenticatorNotPresent = @"The authenticator was not included in the final leg of negotiation.";
public const string RSTRAuthenticatorIncorrect = @"The RequestSecurityTokenResponse CombinedHash is incorrect.";
public const string ClientCertificateNotProvided = @"The certificate for the client has not been provided.  The certificate can be set on the ClientCredentials or ServiceCredentials.";
public const string ClientCertificateNotProvidedOnServiceCredentials = @"The client certificate is not provided. Specify a client certificate in ServiceCredentials.";
public const string ClientCertificateNotProvidedOnClientCredentials = @"The client certificate is not provided. Specify a client certificate in ClientCredentials.";
public const string ServiceCertificateNotProvidedOnServiceCredentials = @"The service certificate is not provided. Specify a service certificate in ServiceCredentials.";
public const string ServiceCertificateNotProvidedOnClientCredentials = @"The service certificate is not provided for target '{0}'. Specify a service certificate in ClientCredentials.";
public const string UserNamePasswordNotProvidedOnClientCredentials = @"The username is not provided. Specify username in ClientCredentials.";
public const string ObjectIsReadOnly = @"Object is read-only.";
public const string EmptyXmlElementError = @"Element {0} cannot be empty.";
public const string UnexpectedXmlChildNode = @"XML child node {0} of type {1} is unexpected for element {2}.";
public const string ContextAlreadyRegistered = @"The context-id={0} (generation-id={1}) is already registered with SecurityContextSecurityTokenAuthenticator.";
public const string ContextAlreadyRegisteredNoKeyGeneration = @"The context-id={0} (no key generation-id) is already registered with SecurityContextSecurityTokenAuthenticator.";
public const string ContextNotPresent = @"There is no SecurityContextSecurityToken with context-id={0} (generation-id={1}) registered with SecurityContextSecurityTokenAuthenticator.";
public const string ContextNotPresentNoKeyGeneration = @"There is no SecurityContextSecurityToken with context-id={0} (no key generation-id) registered with SecurityContextSecurityTokenAuthenticator.";
public const string InvalidSecurityContextCookie = @"The SecurityContextSecurityToken has an invalid Cookie. The following error occurred when processing the Cookie: '{0}'.";
public const string SecurityContextNotRegistered = @"The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.";
public const string SecurityContextExpired = @"The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) has expired.";
public const string SecurityContextExpiredNoKeyGeneration = @"The SecurityContextSecurityToken with context-id={0} (no key generation-id) has expired.";
public const string NoSecurityContextIdentifier = @"The SecurityContextSecurityToken does not have a context-id.";
public const string MessageMustHaveViaOrToSetForSendingOnServerSideCompositeDuplexChannels = @"For sending a message on server side composite duplex channels, the message must have either the 'Via' property or the 'To' header set.";
public const string MessageViaCannotBeAddressedToAnonymousOnServerSideCompositeDuplexChannels = @"The 'Via' property on the message is set to Anonymous Uri '{0}'. Please set the 'Via' property to a non-anonymous address as message cannot be addressed to anonymous Uri on server side composite duplex channels.";
public const string MessageToCannotBeAddressedToAnonymousOnServerSideCompositeDuplexChannels = @"The 'To' header on the message is set to Anonymous Uri '{0}'. Please set the 'To' header to a non-anonymous address as message cannot be addressed to anonymous Uri on server side composite duplex channels.";
public const string SecurityBindingNotSetUpToProcessOutgoingMessages = @"This SecurityProtocol instance was not set up to process outgoing messages.";
public const string SecurityBindingNotSetUpToProcessIncomingMessages = @"This SecurityProtocol instance was not set up to process incoming messages.";
public const string TokenProviderCannotGetTokensForTarget = @"The token provider cannot get tokens for target '{0}'.";
public const string UnsupportedKeyDerivationAlgorithm = @"Key derivation algorithm '{0}' is not supported.";
public const string CannotFindCorrelationStateForApplyingSecurity = @"Cannot find the correlation state for applying security to reply at the responder.";
public const string ReplyWasNotSignedWithRequiredSigningToken = @"The reply was not signed with the required signing token.";
public const string EncryptionNotExpected = @"Encryption not expected for this message.";
public const string SignatureNotExpected = @"A signature is not expected for this message.";
public const string InvalidQName = @"The QName is invalid.";
public const string UnknownICryptoType = @"The ICrypto implementation '{0}' is not supported.";
public const string SameProtocolFactoryCannotBeSetForBothDuplexDirections = @"On DuplexSecurityProtocolFactory, the same protocol factory cannot be set for the forward and reverse directions.";
public const string SuiteDoesNotAcceptAlgorithm = @"The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.";
public const string TokenDoesNotSupportKeyIdentifierClauseCreation = @"'{0}' does not support '{1}' creation.";
public const string UnableToCreateICryptoFromTokenForSignatureVerification = @"Cannot create an ICrypto interface from the '{0}' token for signature verification.";
public const string MessageSecurityVerificationFailed = @"Message security verification failed.";
public const string TransportSecurityRequireToHeader = @"Transport secured messages should have the 'To' header specified.";
public const string TransportSecuredMessageMissingToHeader = @"The message received over Transport security was missing the 'To' header.";
public const string UnsignedToHeaderInTransportSecuredMessage = @"The message received over Transport security has unsigned 'To' header.";
public const string TransportSecuredMessageHasMoreThanOneToHeader = @"More than one 'To' header specified in a message secured by Transport Security.";
public const string TokenNotExpectedInSecurityHeader = @"Received security header contains unexpected token '{0}'.";
public const string CannotFindCert = @"Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.";
public const string CannotFindCertForTarget = @"Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.";
public const string FoundMultipleCerts = @"Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.";
public const string FoundMultipleCertsForTarget = @"Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.";
public const string MissingKeyInfoInEncryptedKey = @"The KeyInfo clause is missing or empty in EncryptedKey.";
public const string EncryptedKeyWasNotEncryptedWithTheRequiredEncryptingToken = @"The EncryptedKey clause was not wrapped with the required encryption token '{0}'.";
public const string MessageWasNotEncryptedWithTheRequiredEncryptingToken = @"The message was not encrypted with the required encryption token.";
public const string TimestampMustOccurFirstInSecurityHeaderLayout = @"The timestamp must occur first in this security header layout.";
public const string TimestampMustOccurLastInSecurityHeaderLayout = @"The timestamp must occur last in this security header layout.";
public const string AtMostOnePrimarySignatureInReceiveSecurityHeader = @"Only one primary signature is allowed in a security header.";
public const string SigningTokenHasNoKeys = @"The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).";
public const string SigningTokenHasNoKeysSupportingTheAlgorithmSuite = @"The signing token {0} has no key that supports the algorithm suite {1}.";
public const string DelayedSecurityApplicationAlreadyCompleted = @"Delayed security application has already been completed.";
public const string UnableToResolveKeyInfoClauseInDerivedKeyToken = @"Cannot resolve KeyInfo in derived key token for resolving source token: KeyInfoClause '{0}'.";
public const string UnableToDeriveKeyFromKeyInfoClause = @"KeyInfo clause '{0}' resolved to token '{1}', which does not contain a Symmetric key that can be used for derivation.";
public const string UnableToResolveKeyInfoForVerifyingSignature = @"Cannot resolve KeyInfo for verifying signature: KeyInfo '{0}', available tokens '{1}'.";
public const string UnableToResolveKeyInfoForUnwrappingToken = @"Cannot resolve KeyInfo for unwrapping key: KeyInfo '{0}', available tokens '{1}'.";
public const string UnableToResolveKeyInfoForDecryption = @"Cannot resolve KeyInfo for decryption: KeyInfo '{0}', available tokens '{1}'.";
public const string EmptyBase64Attribute = @"An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.";
public const string RequiredSecurityHeaderElementNotSigned = @"The security header element '{0}' with the '{1}' id must be signed.";
public const string RequiredSecurityTokenNotSigned = @"The '{0}' security token with the '{1}' attachment mode must be signed.";
public const string RequiredSecurityTokenNotEncrypted = @"The '{0}' security token with the '{1}' attachment mode must be encrypted.";
public const string MessageBodyOperationNotValidInBodyState = @"Operation '{0}' is not valid in message body state '{1}'.";
public const string EncryptedKeyWithReferenceListNotAllowed = @"EncryptedKey with ReferenceList is not allowed according to the current settings.";
public const string UnableToFindTokenAuthenticator = @"Cannot find a token authenticator for the '{0}' token type. Tokens of that type cannot be accepted according to current security settings.";
public const string NoPartsOfMessageMatchedPartsToSign = @"No signature was created because not part of the message matched the supplied message part specification.";
public const string BasicTokenCannotBeWrittenWithoutEncryption = @"Supporting SecurityToken cannot be written without encryption.";
public const string DuplicateIdInMessageToBeVerified = @"The '{0}' id occurred twice in the message that is supplied for verification.";
public const string UnsupportedCanonicalizationAlgorithm = @"Canonicalization algorithm '{0}' is not supported.";
public const string NoKeyInfoInEncryptedItemToFindDecryptingToken = @"The KeyInfo value was not found in the encrypted item to find the decrypting token.";
public const string NoKeyInfoInSignatureToFindVerificationToken = @"No KeyInfo in signature to find verification token.";
public const string SecurityHeaderIsEmpty = @"Security header is empty.";
public const string EncryptionMethodMissingInEncryptedData = @"The encryption method is missing in encrypted data.";
public const string EncryptedHeaderAttributeMismatch = @"The Encrypted Header and the Security Header '{0}' attribute did not match. Encrypted Header: {1}. Security Header: {2}.";
public const string AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck = @"At most one reference list is supported with default policy check.";
public const string AtMostOneSignatureIsSupportedWithDefaultPolicyCheck = @"At most one signature is supported with default policy check.";
public const string UnexpectedEncryptedElementInSecurityHeader = @"Unexpected encrypted element in security header.";
public const string MissingIdInEncryptedElement = @"Id is missing in encrypted item in security header.";
public const string InvalidDataReferenceInReferenceList = @"The data reference '{0}' in encryption reference list is not valid.";
public const string TokenManagerCannotCreateTokenReference = @"The supplied token manager cannot create a token reference.";
public const string TimestampToSignHasNoId = @"The timestamp element added to security header to sign has no id.";
public const string EncryptedHeaderXmlMustHaveId = @"An encrypted header must have an id.";
public const string UnableToResolveDataReference = @"The data reference '{0}' could not be resolved in the received message.";
public const string TimestampAlreadySetForSecurityHeader = @"A timestamp element has already been set for this security header.";
public const string DuplicateTimestampInSecurityHeader = @"More than one Timestamp element was present in security header.";
public const string MismatchInSecurityOperationToken = @"The incoming message was signed with a token which was different from what used to encrypt the body.  This was not expected.";
public const string UnableToCreateSymmetricAlgorithmFromToken = @"Cannot create the '{0}' symmetric algorithm from the token.";
public const string UnknownEncodingInBinarySecurityToken = @"Unrecognized encoding occurred while reading the binary security token.";
public const string UnableToResolveReferenceUriForSignature = @"Cannot resolve reference URI '{0}' in signature to compute digest.";
public const string NoTimestampAvailableInSecurityHeaderToDoReplayDetection = @"No timestamp is available in the security header to do replay detection.";
public const string NoSignatureAvailableInSecurityHeaderToDoReplayDetection = @"No signature is available in the security header to provide the nonce for replay detection.";
public const string CouldNotFindNamespaceForPrefix = @"There is no namespace binding for prefix '{0}' in scope.";
public const string DerivedKeyCannotDeriveFromSecret = @"Derived Key Token cannot derive key from the secret.";
public const string DerivedKeyPosAndGenBothSpecified = @"Both offset and generation cannot be specified for Derived Key Token.";
public const string DerivedKeyPosAndGenNotSpecified = @"Either offset or generation must be specified for Derived Key Token.";
public const string DerivedKeyTokenRequiresTokenReference = @"DerivedKeyToken requires a reference to a token.";
public const string DerivedKeyLengthTooLong = @"DerivedKey length ({0}) exceeds the allowed settings ({1}).";
public const string DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong = @"The Implicit derived key clause '{0}' specifies a derivation key length ({1}) which exceeds the allowed maximum length ({2}).";
public const string DerivedKeyInvalidOffsetSpecified = @"The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.";
public const string DerivedKeyInvalidGenerationSpecified = @"The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.";
public const string ChildNodeTypeMissing = @"The XML element {0} does not have a child of type {1}.";
public const string NoLicenseXml = @"RequestedSecurityToken not specified in RequestSecurityTokenResponse.";
public const string UnsupportedBinaryEncoding = @"Binary encoding {0} is not supported.";
public const string BadKeyEncryptionAlgorithm = @"Invalid key encryption algorithm {0}.";
public const string AsyncObjectAlreadyEnded = @"End has already been called on this asynchronous result object.";
public const string InvalidAsyncResult = @"The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.";
public const string UnableToCreateTokenReference = @"Unable to create token reference.";
public const string ConfigNull = @"null";
public const string NonceLengthTooShort = @"The specified nonce is too short. The minimum required nonce length is 4 bytes.";
public const string NoBinaryNegoToSend = @"There is no binary negotiation to send to the other party.";
public const string BadSecurityNegotiationContext = @"Security negotiation failure because an incorrect Context attribute specified in RequestSecurityToken/RequestSecurityTokenResponse from the other party.";
public const string NoBinaryNegoToReceive = @"No binary negotiation was received from the other party.";
public const string ProofTokenWasNotWrappedCorrectly = @"The proof token was not wrapped correctly in the RequestSecurityTokenResponse.";
public const string NoServiceTokenReceived = @"Final RSTR from other party does not contain a service token.";
public const string InvalidSspiNegotiation = @"The Security Support Provider Interface (SSPI) negotiation failed.";
public const string CannotAuthenticateServer = @"Cannot authenticate the other party.";
public const string IncorrectBinaryNegotiationValueType = @"Incoming binary negotiation has invalid ValueType {0}.";
public const string ChannelNotOpen = @"The channel is not open.";
public const string FailToRecieveReplyFromNegotiation = @"Security negotiation failed because the remote party did not send back a reply in a timely manner. This may be because the underlying transport connection was aborted.";
public const string MessageSecurityVersionOutOfRange = @"SecurityVersion must be WsSecurity10 or WsSecurity11.";
public const string CreationTimeUtcIsAfterExpiryTime = @"Creation time must be before expiration time.";
public const string NegotiationStateAlreadyPresent = @"Negotiation state already exists for context '{0}'.";
public const string CannotFindNegotiationState = @"Cannot find the negotiation state for the context '{0}'.";
public const string OutputNotExpected = @"Send cannot be called when the session does not expect output.";
public const string SessionClosedBeforeDone = @"The session was closed before message transfer was complete.";
public const string CacheQuotaReached = @"The item cannot be added. The maximum cache size is ({0} items).";
public const string NoServerX509TokenProvider = @"The server's X509SecurityTokenProvider cannot be null.";
public const string UnexpectedBinarySecretType = @"Expected binary secret of type {0} but got secret of type {1}.";
public const string UnsupportedPasswordType = @"The '{0}' username token has an unsupported password type.";
public const string NoPassword = @"No password specified for username '{0}'.";
public const string UnrecognizedIdentityPropertyType = @"Unrecognized identity property type: '{0}'.";
public const string UnableToDemuxChannel = @"There was no channel that could accept the message with action '{0}'.";
public const string EndpointNotFound = @"There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details. In Silverlight, a 404 response code may be reported even when the service sends a different error code.";
public const string MaxReceivedMessageSizeMustBeInIntegerRange = @"This factory buffers messages, so the message sizes must be in the range of an integer value.";
public const string MaxBufferSizeMustMatchMaxReceivedMessageSize = @"Because messages are being buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.";
public const string MaxBufferSizeMustNotExceedMaxReceivedMessageSize = @"MaxBufferSize must not exceed MaxReceivedMessageSize.";
public const string MessageSizeMustBeInIntegerRange = @"This Factory buffers messages, so the message sizes must be in the range of a int value.";
public const string UriLengthExceedsMaxSupportedSize = @"URI {0} could not be set because its size ({1}) exceeds the max supported size ({2}).";
public const string InValidateIdPrefix = @"Expecting first char - c - to be in set [Char.IsLetter(c) && c == '_', found '{0}'.";
public const string InValidateId = @"Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.";
public const string HttpRegistrationAlreadyExists = @"HTTP could not register URL {0}. Another application has already registered this URL with HTTP.SYS.";
public const string HttpRegistrationAccessDenied = @"HTTP could not register URL {0}. Your process does not have access rights to this namespace (see http://go.microsoft.com/fwlink/?LinkId=70353 for details).";
public const string HttpRegistrationPortInUse = @"HTTP could not register URL {0} because TCP port {1} is being used by another application.";
public const string HttpRegistrationLimitExceeded = @"HTTP could not register URL {0} because the MaxEndpoints quota has been exceeded. To correct this, either close other HTTP-based services, or increase your MaxEndpoints registry key setting (see http://go.microsoft.com/fwlink/?LinkId=70352 for details).";
public const string UnexpectedHttpResponseCode = @"The remote server returned an unexpected response: ({0}) {1}. In Silverlight, a 404 response code may be reported even when the service sends a different error code.";
public const string HttpContentLengthIncorrect = @"The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.";
public const string OneWayUnexpectedResponse = @"A response was received from a one-way send over the underlying IRequestChannel. Make sure the remote endpoint has a compatible binding at its endpoint (one that contains OneWayBindingElement).";
public const string MissingContentType = @"The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.";
public const string DuplexChannelAbortedDuringOpen = @"Duplex channel to {0} was aborted during the open process.";
public const string OperationAbortedDuringConnectionEstablishment = @"Operation was aborted while establishing a connection to {0}.";
public const string HttpAddressingNoneHeaderOnWire = @"The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.";
public const string MessageXmlProtocolError = @"There is a problem with the XML that was received from the network. See inner exception for more details.";
public const string TcpV4AddressInvalid = @"An IPv4 address was specified ({0}), but IPv4 is not enabled on this machine.";
public const string TcpV6AddressInvalid = @"An IPv6 address was specified ({0}), but IPv6 is not enabled on this machine.";
public const string UniquePortNotAvailable = @"Cannot find a unique port number that is available for both IPv4 and IPv6.";
public const string TcpAddressInUse = @"There is already a listener on IP endpoint {0}.  Make sure that you are not trying to use this endpoint multiple times in your application and that there are no other applications listening on this endpoint.";
public const string TcpConnectNoBufs = @"Insufficient winsock resources available to complete socket connection initiation.";
public const string InsufficentMemory = @"Insufficient memory avaliable to complete the operation.";
public const string TcpConnectError = @"Could not connect to {0}. TCP error code {1}: {2}.";
public const string TcpConnectErrorWithTimeSpan = @"Could not connect to {0}. The connection attempt lasted for a time span of {3}. TCP error code {1}: {2}.";
public const string TcpListenError = @"A TCP error ({0}: {1}) occurred while listening on IP Endpoint={2}.";
public const string TcpTransferError = @"A TCP error ({0}: {1}) occurred while transmitting data.";
public const string TcpLocalConnectionAborted = @"The socket connection was aborted by your local machine. This could be caused by a channel Abort(), or a transmission error from another thread using this socket.";
public const string HttpResponseAborted = @"The HTTP request context was aborted while writing the response.  As a result, the response may not have been completely written to the network.  This can be remedied by gracefully closing the request context rather than aborting it.";
public const string TcpConnectionResetError = @"The socket connection was aborted. This could be caused by an error processing your message or a receive timeout being exceeded by the remote host, or an underlying network resource issue. Local socket timeout was '{0}'.";
public const string TcpConnectionTimedOut = @"The socket transfer timed out after {0}. You have exceeded the timeout set on your binding. The time allotted to this operation may have been a portion of a longer timeout.";
public const string SocketConnectionDisposed = @"The socket connection has been disposed.";
public const string SocketListenerDisposed = @"The socket listener has been disposed.";
public const string SocketListenerNotListening = @"The socket listener is not listening.";
public const string DuplexSessionListenerNotFound = @"No duplex session listener was listening at {0}. This could be due to an incorrect via set on the client or a binding mismatch.";
public const string HttpTargetNameDictionaryConflict = @"The entry found in AuthenticationManager's CustomTargetNameDictionary for {0} does not match the requested identity of {1}.";
public const string HttpContentTypeHeaderRequired = @"An HTTP Content-Type header is required for SOAP messaging and none was found.";
public const string ContentTypeMismatch = @"Content Type {0} was sent to a service expecting {1}.  The client and service bindings may be mismatched.";
public const string ResponseContentTypeMismatch = @"The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.";
public const string ResponseContentTypeNotSupported = @"The content type {0} of the message is not supported by the encoder.";
public const string HttpToMustEqualVia = @"The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.";
public const string NullReferenceOnHttpResponse = @"The server challenged this request and streamed requests cannot be resubmitted. To enable HTTP server challenges, set your TransferMode to Buffered or StreamedResponse.";
public const string FramingContentTypeMismatch = @"Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.";
public const string FramingFaultUnrecognized = @"Server faulted with code '{0}'.";
public const string FramingContentTypeTooLongFault = @"Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.";
public const string FramingViaTooLongFault = @"Via '{0}' is too long to be processed by the remote host. See the server logs for more details.";
public const string FramingModeNotSupportedFault = @"The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.";
public const string FramingVersionNotSupportedFault = @"The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.";
public const string FramingUpgradeInvalid = @"The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).";
public const string SecurityServerTooBusy = @"Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.";
public const string SecurityEndpointNotFound = @"Server '{0}' sent back a fault indicating it is in the process of shutting down. Please see the inner exception for fault details.";
public const string ServerTooBusy = @"Server '{0}' is too busy to process this request. Try again later.";
public const string UpgradeProtocolNotSupported = @"Protocol Type {0} was sent to a service that does not support that type of upgrade.";
public const string UpgradeRequestToNonupgradableService = @".Net Framing upgrade request for {0} was sent to a service that is not setup to receive upgrades.";
public const string PreambleAckIncorrect = @"You have tried to create a channel to a service that does not support .Net Framing.";
public const string PreambleAckIncorrectMaybeHttp = @"You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.";
public const string StreamError = @"An error occurred while transmitting data.";
public const string ServerRejectedUpgradeRequest = @"The server rejected the upgrade request.";
public const string ServerRejectedSessionPreamble = @"The server at {0} rejected the session-establishment request.";
public const string UnableToResolveHost = @"Cannot resolve the host name of URI \""{0}\"" using DNS.";
public const string HttpRequiresSingleAuthScheme = @"The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.";
public const string HttpProxyRequiresSingleAuthScheme = @"The '{0}' authentication scheme has been specified for the proxy on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.";
public const string HttpMutualAuthNotSatisfied = @"The remote HTTP server did not satisfy the mutual authentication requirement.";
public const string HttpAuthorizationFailed = @"The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.";
public const string HttpAuthenticationFailed = @"The HTTP request with client authentication scheme '{0}' failed with '{1}' status.";
public const string HttpAuthorizationForbidden = @"The HTTP request was forbidden with client authentication scheme '{0}'.";
public const string InvalidUriScheme = @"The provided URI scheme '{0}' is invalid; expected '{1}'.";
public const string HttpAuthSchemeAndClientCert = @"The HTTPS listener factory was configured to require a client certificate and the '{0}' authentication scheme. However, only one form of client authentication can be required at once.";
public const string NoTransportManagerForUri = @"Could not find an appropriate transport manager for listen URI '{0}'.";
public const string ListenerFactoryNotRegistered = @"The specified channel listener at '{0}' is not registered with this transport manager.";
public const string HttpsExplicitIdentity = @"The HTTPS channel factory does not support explicit specification of an identity in the EndpointAddress unless the authentication scheme is NTLM or Negotiate.";
public const string HttpsIdentityMultipleCerts = @"The endpoint identity specified when creating the HTTPS channel to '{0}' contains multiple server certificates.  However, the HTTPS transport only supports the specification of a single server certificate.  In order to create an HTTPS channel, please specify no more than one server certificate in the endpoint identity.";
public const string HttpsServerCertThumbprintMismatch = @"The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.";
public const string DuplicateRegistration = @"A registration already exists for URI '{0}'.";
public const string SecureChannelFailure = @"Could not establish secure channel for SSL/TLS with authority '{0}'.";
public const string TrustFailure = @"Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.";
public const string NoCompatibleTransportManagerForUri = @"Could not find a compatible transport manager for URI '{0}'.";
public const string HttpSpnNotFound = @"The SPN for the responding server at URI '{0}' could not be determined.";
public const string StreamMutualAuthNotSatisfied = @"The remote server did not satisfy the mutual authentication requirement.";
public const string TransferModeNotSupported = @"Transfer mode {0} is not supported by {1}.";
public const string InvalidTokenProvided = @"The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.";
public const string NoUserNameTokenProvided = @"The required UserNameSecurityToken was not provided.";
public const string RemoteIdentityFailedVerification = @"The following remote identity failed verification: '{0}'.";
public const string UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress = @"You cannot specify an explicit Proxy Address as well as UseDefaultWebProxy=true in your HTTP Transport Binding Element.";
public const string ProxyImpersonationLevelMismatch = @"The HTTP proxy authentication credential specified an impersonation level restriction ({0}) that is stricter than the restriction for target server authentication ({1}).";
public const string ProxyAuthenticationLevelMismatch = @"The HTTP proxy authentication credential specified an mutual authentication requirement ({0}) that is stricter than the requirement for target server authentication ({1}).";
public const string CredentialDisallowsNtlm = @"The NTLM authentication scheme was specified, but the target credential does not allow NTLM.";
public const string DigestExplicitCredsImpersonationLevel = @"The impersonation level '{0}' was specified, yet HTTP Digest authentication can only support 'Impersonation' level when used with an explicit credential.";
public const string UriGeneratorSchemeMustNotBeEmpty = @"The scheme parameter must not be empty.";
public const string UnsupportedSslProtectionLevel = @"The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.";
public const string HttpNoTrackingService = @"{0}. This often indicates that a service that HTTP.SYS depends upon (such as httpfilter) is not started.";
public const string HttpNetnameDeleted = @"{0}. This often indicates that the HTTP client has prematurely closed the underlying TCP connection.";
public const string TimeoutInputQueueDequeue1 = @"A Dequeue operation timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string TimeoutServiceChannelConcurrentOpen1 = @"Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string TimeoutServiceChannelConcurrentOpen2 = @"Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string TimeSpanMustbeGreaterThanTimeSpanZero = @"TimeSpan must be greater than TimeSpan.Zero.";
public const string ValueMustBeNonNegative = @"The value of this argument must be non-negative.";
public const string ValueMustBePositive = @"The value of this argument must be positive.";
public const string ValueMustBeGreaterThanZero = @"The value of this argument must be greater than 0.";
public const string ValueMustBeInRange = @"The value of this argument must fall within the range {0} to {1}.";
public const string OffsetExceedsBufferBound = @"The specified offset exceeds the upper bound of the buffer ({0}).";
public const string OffsetExceedsBufferSize = @"The specified offset exceeds the buffer size ({0} bytes).";
public const string SizeExceedsRemainingBufferSpace = @"The specified size exceeds the remaining buffer space ({0} bytes).";
public const string SpaceNeededExceedsMessageFrameOffset = @"The space needed for encoding ({0} bytes) exceeds the message frame offset.";
public const string FaultConverterDidNotCreateFaultMessage = @"{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.";
public const string FaultConverterCreatedFaultMessage = @"{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.";
public const string FaultConverterDidNotCreateException = @"{0} returned true from OnTryCreateException, but did not return an Exception.";
public const string FaultConverterCreatedException = @"{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).";
public const string InfoCardInvalidChain = @"Policy chain contains self issued URI or a managed issuer in the wrong position.";
public const string FullTrustOnlyBindingElementSecurityCheck1 = @"The Binding with name {0} failed validation because it contains a BindingElement with type {1} which is not supported in partial trust. Consider using BasicHttpBinding or WSHttpBinding, or hosting your application in a full-trust environment.";
public const string FullTrustOnlyBindingElementSecurityCheckWSHttpBinding1 = @"The WSHttpBinding with name {0} failed validation because it contains a BindingElement with type {1} which is not supported in partial trust. Consider disabling the message security and reliable session options, using BasicHttpBinding, or hosting your application in a full-trust environment.";
public const string FullTrustOnlyBindingSecurityCheck1 = @"The Binding with name {0} failed validation because the Binding type {1} is not supported in partial trust. Consider using BasicHttpBinding or WSHttpBinding, or hosting your application in a full-trust environment.";
public const string PartialTrustServiceCtorNotVisible = @"The Service with name '{0}' could not be constructed because the application does not have permission to construct the type: both the Type and its default parameter-less constructor must be public.";
public const string PartialTrustServiceMethodNotVisible = @"The Method with name '{1}' in Type '{0}' could not be invoked because the application does not have permission to invoke the method: both the Method and its containing Type must be public.";
public const string PartialTrustNonHttpActivation = @"The operation is not supported because the protocol {0} is enabled for application '{1}' and the application is running in partial trust. Only the http and https protocols are supported in partial trust applications. Either remove the other protocols from the protocol list in the Windows Process Activation Service configuration or configure the application to run in full trust.";
public const string PartialTrustPerformanceCountersNotEnabled = @"Access to performance counters is denied. Application may be running in partial trust. Either disable performance counters or configure the application to run in full trust.";






public const string AcksToMustBeSameAsRemoteAddress = @"The remote endpoint requested an address for acknowledgements that is not the same as the address for application messages. The channel could not be opened because this is not supported. Ensure the endpoint address used to create the channel is identical to the one the remote endpoint was set up with.";
public const string AcksToMustBeSameAsRemoteAddressReason = @"The address for acknowledgements must be the same as the address for application messages. Verify that your endpoint is configured to use the same URI for these two addresses.";
public const string AssertionNotSupported = @"The {0}:{1} assertion is not supported.";
public const string CloseOutputSessionErrorReason = @"An unexpected error occurred while attempting to close the output half of the duplex reliable session.";
public const string ConflictingAddress = @"The remote endpoint sent conflicting requests to create a reliable session. The conflicting requests have inconsistent filter criteria such as address or action. The reliable session has been faulted.";
public const string ConflictingOffer = @"The remote endpoint sent conflicting requests to create a reliable session. The remote endpoint requested both a one way and a two way session. The reliable session has been faulted.";
public const string CouldNotParseWithAction = @"A message with action {0} could not be parsed.";
public const string CSRefused = @"The request to create a reliable session has been refused by the RM Destination. {0} The channel could not be opened.";
public const string CSRefusedAcksToMustEqualEndpoint = @"The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the Endpoint Uri are the same.";
public const string CSRefusedAcksToMustEqualReplyTo = @"The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the ReplyTo Uri are the same.";
public const string CSRefusedDuplexNoOffer = @"The endpoint at {0} processes duplex sessions. The create sequence request must contain an offer for a return sequence. This is likely caused by a binding mismatch.";
public const string CSRefusedInputOffer = @"The endpoint at {0} processes input sessions. The create sequence request must not contain an offer for a return sequence. This is likely caused by a binding mismatch.";
public const string CSRefusedInvalidIncompleteSequenceBehavior = @"The request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.";
public const string CSRefusedNoSTRWSSecurity = @"The request to create a reliable session contains the wsse:SecurityTokenReference but does not carry a wsrm:UsesSequenceSTR header. This is a WS-ReliableMessaging protocol violation. The session could not be created.";
public const string CSRefusedReplyNoOffer = @"The endpoint at {0} processes reply sessions. The create sequence request must contain an offer for a return sequence. This is likely caused by a binding mismatch.";
public const string CSRefusedRequiredSecurityElementMissing = @"The RM Destination requires the WS-SecureConversation protocol in the binding. This is likely caused by a binding mismatch.";
public const string CSRefusedSSLNotSupported = @"The endpoint processing requests to create a reliable session does not support sessions that use SSL. This is likely caused by a binding mismatch. The session could not be created.";
public const string CSRefusedSTRNoWSSecurity = @"The request to create a reliable session carries a wsrm:UsesSequenceSTR header, but does not contain the wsse:SecurityTokenReference. This is a WS-ReliableMessaging protocol violation. The session could not be created.";
public const string CSRefusedUnexpectedElementAtEndOfCSMessage = @"The message is not a valid SOAP message. The body contains more than 1 root element.";
public const string CSResponseOfferRejected = @"The remote endpoint replied to a request for a two way session with an offer for a one way session. This is likely caused by a binding mismatch. The channel could not be opened.";
public const string CSResponseOfferRejectedReason = @"The client requested creation of a two way session. A one way session was created. The session cannot continue without as a one way session. This is likely caused by a binding mismatch.";
public const string CSResponseWithInvalidIncompleteSequenceBehavior = @"The response to the request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.";
public const string CSResponseWithOffer = @"The remote endpoint replied to a request for a one way session with an offer for a two way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.";
public const string CSResponseWithOfferReason = @"A return sequence was not offered by the create sequence request. The create sequence response cannot accept a return sequence.";
public const string CSResponseWithoutOffer = @"The remote endpoint replied to a request for a two way session with an offer for a one way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.";
public const string CSResponseWithoutOfferReason = @"A return sequence was offered by the create sequence request but the create sequence response did not accept this sequence.";
public const string DeliveryAssuranceRequiredNothingFound = @"The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. Nothing was found.";
public const string DeliveryAssuranceRequired = @"The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. The {1} element under the {2} namespace was found.";
public const string EarlyRequestTerminateSequence = @"The remote endpoint sent a TerminateSequence protocol message before fully acknowledging all messages in the reply sequence. This is a violation of the reliable request reply protocol. The reliable session was faulted.";
public const string EarlySecurityClose = @"The remote endpoint has closed the underlying secure session before the reliable session fully completed. The reliable session was faulted.";
public const string EarlySecurityFaulted = @"The underlying secure session has faulted before the reliable session fully completed. The reliable session was faulted.";
public const string EarlyTerminateSequence = @"The remote endpoint has errantly sent a TerminateSequence protocol message before the sequence finished.";
public const string ElementFound = @"The {0}:{1} element requires a {2}:{3} child element but has the {4} child element under the {5} namespace.";
public const string ElementRequired = @"The {0}:{1} element requires a {2}:{3} child element but has no child elements.";
public const string InconsistentLastMsgNumberExceptionString = @"The remote endpoint specified two different last message numbers. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.";
public const string InvalidAcknowledgementFaultReason = @"The SequenceAcknowledgement violates the cumulative acknowledgement invariant.";
public const string InvalidAcknowledgementReceived = @"A violation of acknowledgement protocol has been detected. An InvalidAcknowledgement fault was sent to the remote endpoint and the reliable session was faulted.";
public const string InvalidBufferRemaining = @"An acknowledgement was received indicating the remaining buffer space on the remote endpoint is {0}. This number cannot be less than zero. The reliable session was faulted.";
public const string InvalidSequenceNumber = @"A message was received with a sequence number of {0}. Sequence numbers cannot be less than 1. The reliable session was faulted.";
public const string InvalidSequenceRange = @"An acknowledgement range starting at {0} and ending at {1} was received. This is an invalid acknowledgement range. The reliable session was faulted.";
public const string InvalidWsrmResponseChannelNotOpened = @"The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel could not be opened.";
public const string InvalidWsrmResponseSessionFaultedExceptionString = @"The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel was faulted.";
public const string InvalidWsrmResponseSessionFaultedFaultString = @"The {0} request's response was a message with action {1}. The response must be a {0}Response with action {2}. The reliable session cannot continue.";
public const string LastMessageNumberExceeded = @"A message was received with a sequence number higher than the sequence number of the last message in this sequence. This is a violation of the sequence number protocol. The reliable session was faulted.";
public const string LastMessageNumberExceededFaultReason = @"The value for wsrm:MessageNumber exceeds the value of the MessageNumber accompanying a LastMessage element in this Sequence.";
public const string ManualAddressingNotSupported = @"Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.";
public const string MaximumRetryCountExceeded = @"The maximum retry count has been exceeded with no response from the remote endpoint. The reliable session was faulted. This is often an indication that the remote endpoint is no longer available.";
public const string MessageExceptionOccurred = @"A problem occurred while reading a message. See inner exception for details.";
public const string MessageNumberRollover = @"The maximum message number for this sequence has been exceeded. The reliable session was faulted.";
public const string MessageNumberRolloverFaultReason = @"The maximum value for wsrm:MessageNumber has been exceeded.";
public const string MillisecondsNotConvertibleToBindingRange = @"The {0} assertion's Milliseconds attribute does not fall within the range this binding uses. The ReliableSessionBindingElement could not be created.";
public const string MissingFinalAckExceptionString = @"The remote endpoint did not include a final acknowledgement in the reply to the close sequence request message. This is a violation of the WS-ReliableMessaging protocol. The reliable session was faulted.";
public const string MissingMessageIdOnWsrmRequest = @"The wsa:MessageId header must be present on a wsrm:{0} message.";
public const string MissingRelatesToOnWsrmResponseReason = @"The returned wsrm:{0}Response message was missing the required wsa:RelatesTo header. This is a violation of the WS-Addressing request reply protocol. The reliable session was faulted.";
public const string MissingReplyToOnWsrmRequest = @"The wsa:ReplyTo header must be present on a wsrm:{0} message.";
public const string MultipleVersionsFoundInPolicy = @"More than one version of the {0} assertion was found. The ReliableSessionBindingElement could not be created.";
public const string NoActionNoSequenceHeaderReason = @"The endpoint only processes messages using the WS-ReliableMessaging protocol. The message sent to the endpoint does not have an action or any headers used by the protocol and cannot be processed.";
public const string NonEmptyWsrmMessageIsEmpty = @"A message with action {0} is an empty message. This message cannot be processed because the body of this WS-ReliableMessaging protocol message must carry information pertaining to a reliable session.";
public const string NonWsrmFeb2005ActionNotSupported = @"The action {0} is not supported by this endpoint. Only WS-ReliableMessaging February 2005 messages are processed by this endpoint.";
public const string NotAllRepliesAcknowledgedExceptionString = @"The remote endpoint closed the session before acknowledging all responses. All replies could not be delivered. The reliable session was faulted.";
public const string ReceivedResponseBeforeRequestExceptionString = @"The remote endpoint returned a {0}Response when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session was faulted.";
public const string ReceivedResponseBeforeRequestFaultString = @"The {0}Response was received when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session cannot continue.";
public const string ReplyMissingAcknowledgement = @"The remote endpoint failed to include a required SequenceAcknowledgement header on a reliable reply message. The reliable session was faulted.";
public const string ReliableRequestContextAborted = @"Due to a request context abort call, the reliable reply session channel potentially has a gap in its reply sequence. The ExactlyOnce assurance can no longer be satisfied. The reliable session was faulted.";
public const string RequiredAttributeIsMissing = @"The required {0} attribute is missing from the {1} element in the {2} assertion. The ReliableSessionBindingElement could not be created.";
public const string RequiredMillisecondsAttributeIncorrect = @"The {0} assertion's required Milliseconds attribute is not schema compliant. Milliseconds must be convertible to an unsigned long. The ReliableSessionBindingElement could not be created.";
public const string RMEndpointNotFoundReason = @"The endpoint at {0} has stopped accepting wsrm sessions.";
public const string SequenceClosedFaultString = @"The Sequence is closed and cannot accept new messages.";
public const string SequenceTerminatedAddLastToWindowTimedOut = @"The RM Source could not transfer the last message within the timeout the user specified.";
public const string SequenceTerminatedBeforeReplySequenceAcked = @"The server received a TerminateSequence message before all reply sequence messages were acknowledged. This is a violation of the reply sequence acknowledgement protocol.";
public const string SequenceTerminatedEarlyTerminateSequence = @"The wsrm:TerminateSequence protocol message was transmitted before the sequence was successfully completed.";
public const string SequenceTerminatedInactivityTimeoutExceeded = @"The inactivity timeout of ({0}) has been exceeded.";
public const string SequenceTerminatedInconsistentLastMsgNumber = @"Two different wsrm:LastMsgNumber values were specified. Because of this the reliable session cannot complete.";
public const string SequenceTerminatedMaximumRetryCountExceeded = @"The user specified maximum retry count for a particular message has been exceeded. Because of this the reliable session cannot continue.";
public const string SequenceTerminatedMissingFinalAck = @"The CloseSequence request's reply message must carry a final acknowledgement. This is a violation of the WS-ReliableMessaging protocol. The reliable session cannot continue.";
public const string SequenceTerminatedOnAbort = @"Due to a user abort the reliable session cannot continue.";
public const string SequenceTerminatedQuotaExceededException = @"The necessary size to buffer a sequence message has exceeded the configured buffer quota. Because of this the reliable session cannot continue.";
public const string SequenceTerminatedReliableRequestThrew = @"The session has stopped waiting for a particular reply. Because of this the reliable session cannot continue.";
public const string SequenceTerminatedReplyMissingAcknowledgement = @"A reply message was received with no acknowledgement.";
public const string SequenceTerminatedNotAllRepliesAcknowledged = @"All of the reply sequence's messages must be acknowledged prior to closing the request sequence. This is a violation of the reply sequence's delivery guarantee. The session cannot continue.";
public const string SequenceTerminatedSessionClosedBeforeDone = @"The user of the remote endpoint's reliable session expects no more messages and a new message arrived. Due to this the reliable session cannot continue.";
public const string SequenceTerminatedSmallLastMsgNumber = @"The wsrm:LastMsgNumber value is too small. A message with a larger sequence number has already been received.";
public const string SequenceTerminatedUnexpectedAcknowledgement = @"The RM destination received an acknowledgement message. The RM destination does not process acknowledgement messages.";
public const string SequenceTerminatedUnexpectedAckRequested = @"The RM source received an AckRequested message. The RM source does not process AckRequested messages.";
public const string SequenceTerminatedUnexpectedCloseSequence = @"The RM source received an CloseSequence message. The RM source does not process CloseSequence messages.";
public const string SequenceTerminatedUnexpectedCloseSequenceResponse = @"The RM destination received an CloseSequenceResponse message. The RM destination does not process CloseSequenceResponse messages.";
public const string SequenceTerminatedUnexpectedCS = @"The RM source received a CreateSequence request. The RM source does not process CreateSequence requests.";
public const string SequenceTerminatedUnexpectedCSOfferId = @"The RM destination received multiple CreateSequence requests with different OfferId values over the same session.";
public const string SequenceTerminatedUnexpectedCSR = @"The RM destination received a CreateSequenceResponse message. The RM destination does not process CreateSequenceResponse messages.";
public const string SequenceTerminatedUnexpectedCSROfferId = @"The RM source received multiple CreateSequenceResponse messages with different sequence identifiers over the same session.";
public const string SequenceTerminatedUnexpectedTerminateSequence = @"The RM source received a TerminateSequence message. The RM source does not process TerminateSequence messages.";
public const string SequenceTerminatedUnexpectedTerminateSequenceResponse = @"The RM destination received a TerminateSequenceResponse message. The RM destination does not process TerminateSequenceResponse messages.";
public const string SequenceTerminatedUnsupportedClose = @"The RM source does not support an RM destination initiated close since messages can be lost. The reliable session cannot continue.";
public const string SequenceTerminatedUnsupportedTerminateSequence = @"The RM source does not support an RM destination initiated termination since messages can be lost. The reliable session cannot continue.";
public const string SequenceTerminatedUnknownAddToWindowError = @"An unknown error occurred while trying to add a sequence message to the window.";
public const string SmallLastMsgNumberExceptionString = @"The remote endpoint specified a last message number that is smaller than a sequence number that has already been seen. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.";
public const string TimeoutOnAddToWindow = @"The message could not be transferred within the allotted timeout of {0}. There was no space available in the reliable channel's transfer window. The time allotted to this operation may have been a portion of a longer timeout.";
public const string TimeoutOnClose = @"The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string TimeoutOnOpen = @"The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string TimeoutOnOperation = @"The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string TimeoutOnRequest = @"The request operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string TimeoutOnSend = @"The send operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.";
public const string UnexpectedAcknowledgement = @"The remote endpoint sent an unexpected ack. Simplex servers do not process acks.";
public const string UnexpectedAckRequested = @"The remote endpoint sent an unexpected request for an ack. Simplex clients do not send acks and do not process requests for acks.";
public const string UnexpectedCloseSequence = @"The remote endpoint sent an unexpected close sequence message. Simplex clients do not process this message.";
public const string UnexpectedCloseSequenceResponse = @"The remote endpoint sent an unexpected close sequence response message. Simplex servers do not process this message.";
public const string UnexpectedCS = @"The remote endpoint sent an unexpected request to create a sequence. Clients do not process requests for a sequence.";
public const string UnexpectedCSR = @"The remote endpoint sent an unexpected create sequence response. Servers do not process this message.";
public const string UnexpectedCSOfferId = @"The remote endpoint sent inconsistent requests to create the same sequence. The OfferId values are not identical.";
public const string UnexpectedCSROfferId = @"The remote endpoint sent inconsistent responses to the same create sequence request. The sequence identifiers are not identical.";
public const string UnexpectedTerminateSequence = @"The remote endpoint sent an unexpected terminate sequence message. Simplex clients do not process this message.";
public const string UnexpectedTerminateSequenceResponse = @"The remote endpoint sent an unexpected terminate sequence response message. Simplex servers do not process this message.";
public const string UnparsableCSResponse = @"The remote endpoint replied to the request for a sequence with a response that could not be parsed. See inner exception for details. The channel could not be opened.";
public const string UnknownSequenceFaultReason = @"The value of wsrm:Identifier is not a known Sequence identifier.";
public const string UnknownSequenceFaultReceived = @"The remote endpoint no longer recognizes this sequence. This is most likely due to an abort on the remote endpoint. {0} The reliable session was faulted.";
public const string UnknownSequenceMessageReceived = @"The remote endpoint has sent a message containing an unrecognized sequence identifier. The reliable session was faulted.";
public const string UnrecognizedFaultReceived = @"The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The reliable session was faulted.";
public const string UnrecognizedFaultReceivedOnOpen = @"The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The channel could not be opened.";
public const string UnsupportedCloseExceptionString = @"The remote endpoint closed the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.";
public const string UnsupportedTerminateSequenceExceptionString = @"The remote endpoint terminated the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.";
public const string WrongIdentifierFault = @"The remote endpoint has sent an fault message with an unexpected sequence identifier over a session. The fault may be intended for a different session. The fault reason is: {0} The reliable session was faulted.";
public const string WSHttpDoesNotSupportRMWithHttps = @"Binding validation failed because the WSHttpBinding does not support reliable sessions over transport security (HTTPS). The channel factory or service host could not be opened. Use message security for secure reliable messaging over HTTP.";
public const string WsrmFaultReceived = @"The sequence has been terminated by the remote endpoint. {0} The reliable session was faulted.";
public const string WsrmMessageProcessingError = @"An error occurred while processing a message. {0}";
public const string WsrmMessageWithWrongRelatesToExceptionString = @"The returned {0}Response was carrying the a wsa:RelatesTo header that does not correlate with the wsa:MessageId header on the {0} request. This is a violation of the WS-Addressing request reply protocol. The reliable session cannot continue.";
public const string WsrmMessageWithWrongRelatesToFaultString = @"The remote endpoint has responded to a {0} request message with an invalid reply. The reply has a wsa:RelatesTo header with an unexpected identifier. The reliable session cannot continue.";
public const string WsrmRequestIncorrectReplyToExceptionString = @"The remote endpoint sent a wsrm:{0} request message with a wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.";
public const string WsrmRequestIncorrectReplyToFaultString = @"The wsrm:{0} request message's wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.";
public const string WsrmRequiredExceptionString = @"The incoming message is not a WS-ReliableMessaging 1.1 message and could not be processed.";
public const string WsrmRequiredFaultString = @"The RM server requires the use of WS-ReliableMessaging 1.1 protocol. This is likely caused by a binding mismatch.";









public const string SFxActionDemuxerDuplicate = @"The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.";
public const string SFxActionMismatch = @"Cannot create a typed message due to action mismatch, expecting {0} encountered {1}";
public const string SFxAnonymousTypeNotSupported = @"Part {1} in message {0} cannot be exported with RPC or encoded since its type is anonymous.";
public const string SFxAsyncResultsDontMatch0 = @"The IAsyncResult returned from Begin and the IAsyncResult supplied to the Callback are on different objects. These are required to be the same object.";
public const string SFXBindingNameCannotBeNullOrEmpty = @"Binding name cannot be null or empty.";
public const string SFXUnvalidNamespaceValue = @"Value '{0}' provided for {1} property is an invalid URI.";
public const string SFXUnvalidNamespaceParam = @"Parameter value '{0}' is an invalid URI.";
public const string SFXHeaderNameCannotBeNullOrEmpty = @"Header name cannot be null or empty.";
public const string SFxEndpointNoMatchingScheme = @"Could not find a base address that matches scheme {0} for the endpoint with binding {1}. Registered base address schemes are [{2}].";
public const string SFxBadByReferenceParameterMetadata = @"Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.";
public const string SFxBadByValueParameterMetadata = @"Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.";
public const string SFxBadMetadataMustBePolicy = @"When calling the CreateFromPolicy method, the policy argument must be an XmlElement instance with LocalName '{1}' and NamespaceUri '{0}'. This XmlElement has LocalName '{3}' and NamespaceUri '{2}'.";
public const string SFxBadMetadataLocationUri = @"The URI supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config must be a relative URI or an absolute URI with an http or https scheme. '{0}' was specified, which is a absolute URI with {1} scheme.";
public const string SFxBadMetadataLocationNoAppropriateBaseAddress = @"The URL supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config was a relative URL and there is no base address with which to resolve it. '{0}' was specified.";
public const string SFxBadMetadataDialect = @"There was a problem reading the MetadataSet argument: a MetadataSection instance with identifier '{0}' and dialect '{1}' has a Metadata property whose type does not match the dialect. The expected Metadata type for this dialect is '{2}' but was found to be '{3}'.";
public const string SFxBadMetadataReference = @"Metadata contains a reference that cannot be resolved: '{0}'.";
public const string SFxMaximumResolvedReferencesOutOfRange = @"The MaximumResolvedReferences property of MetadataExchangeClient must be greater than or equal to one.  '{0}' was specified.";
public const string SFxMetadataExchangeClientNoMetadataAddress = @"The MetadataExchangeClient was not supplied with a MetadataReference or MetadataLocation from which to get metadata.  You must supply one to the constructor, to the GetMetadata method, or to the BeginGetMetadata method.";
public const string SFxMetadataExchangeClientCouldNotCreateChannelFactory = @"The MetadataExchangeClient could not create an IChannelFactory for: address='{0}', dialect='{1}', and  identifier='{2}'.";
public const string SFxMetadataExchangeClientCouldNotCreateWebRequest = @"The MetadataExchangeClient could not create an HttpWebRequest for: address='{0}', dialect='{1}', and  identifier='{2}'.";
public const string SFxMetadataExchangeClientCouldNotCreateChannelFactoryBadScheme = @"The MetadataExchangeClient instance could not be initialized because no Binding is available for scheme '{0}'. You can supply a Binding in the constructor, or specify a configurationName.";
public const string SFxBadTransactionProtocols = @"The TransactionProtocol setting was not understood. A supported protocol must be specified.";
public const string SFxMetadataResolverKnownContractsArgumentCannotBeEmpty = @"The MetadataResolver cannot recieve an empty contracts argument to the Resolve or BeginResolve methods.  You must supply at least one ContractDescription.";
public const string SFxMetadataResolverKnownContractsUniqueQNames = @"The ContractDescriptions in contracts must all have unique Name and Namespace pairs.  More than one ContractDescription had the pair Name='{0}' and Namespace='{1}'.";
public const string SFxMetadataResolverKnownContractsCannotContainNull = @"The contracts argument to the Resolve or BeginResolve methods cannot contain a null ContractDescription.";
public const string SFxBindingDoesNotHaveATransportBindingElement = @"The binding specified to do metadata exchange does not contain a TransportBindingElement.";
public const string SFxBindingMustContainTransport2 = @"The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.";
public const string SFxBodyCannotBeNull = @"Body object cannot be null in message {0}";
public const string SFxBodyObjectTypeCannotBeInherited = @"Type {0} cannot inherit from any class other than object to be used as body object in RPC style.";
public const string SFxBodyObjectTypeCannotBeInterface = @"Type {0} implements interface {1} which is not supported for body object in RPC style.";
public const string SFxCallbackBehaviorAttributeOnlyOnDuplex = @"CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.";
public const string SFxCallbackRequestReplyInOrder1 = @"This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.";
public const string SfxCallbackTypeCannotBeNull = @"In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.";
public const string SFxCannotActivateCallbackInstace = @"The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.";
public const string SFxCannotCallAddBaseAddress = @"ServiceHostBase's AddBaseAddress method cannot be called after the InitializeDescription method has completed.";
public const string SFxCannotCallAutoOpenWhenExplicitOpenCalled = @"Cannot make a call on this channel because a call to Open() is in progress.";
public const string SFxCannotGetMetadataFromRelativeAddress = @"The MetadataExchangeClient can only get metadata from absolute addresses.  It cannot get metadata from '{0}'.";
public const string SFxCannotHttpGetMetadataFromAddress = @"The MetadataExchangeClient can only get metadata from http or https addresses when using MetadataExchangeClientMode HttpGet. It cannot get metadata from '{0}'.";
public const string SFxCannotGetMetadataFromLocation = @"The MetadataExchangeClient can only get metadata from http and https MetadataLocations.  It cannot get metadata from '{0}'.";
public const string SFxCannotHaveDifferentTransactionProtocolsInOneBinding = @"The configured policy specifies more than one TransactionProtocol across the operations. A single TransactionProtocol for each endpoint must be specified.";
public const string SFxCannotImportAsParameters_Bare = @"Generating message contract since the operation {0} is neither RPC nor document wrapped.";
public const string SFxCannotImportAsParameters_DifferentWrapperNs = @"Generating message contract since the wrapper namespace ({1}) of message {0} does not match the default value ({2})";
public const string SFxCannotImportAsParameters_DifferentWrapperName = @"Generating message contract since the wrapper name ({1}) of message {0} does not match the default value ({2})";
public const string SFxCannotImportAsParameters_ElementIsNotNillable = @"Generating message contract since element name {0} from namespace {1} is not marked nillable";
public const string SFxCannotImportAsParameters_MessageHasProtectionLevel = @"Generating message contract since message {0} requires protection.";
public const string SFxCannotImportAsParameters_HeadersAreIgnoredInEncoded = @"Headers are not supported in RPC encoded format. Headers are ignored in message {0}.";
public const string SFxCannotImportAsParameters_HeadersAreUnsupported = @"Generating message contract since message {0} has headers";
public const string SFxCannotImportAsParameters_Message = @"Generating message contract since the operation {0} has untyped Message as argument or return type";
public const string SFxCannotImportAsParameters_NamespaceMismatch = @"Generating message contract since message part namespace ({0}) does not match the default value ({1})";
public const string SFxCannotRequireBothSessionAndDatagram3 = @"There are two contracts listening on the same binding ({2}) and address with conflicting settings.  Specifically, the contract '{0}' specifies SessionMode.NotAllowed while the contract '{1}' specifies SessionMode.Required.  You should either change one of the SessionMode values or specify a different address (or ListenUri) for each endpoint.";
public const string SFxCannotSetExtensionsByIndex = @"This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.";
public const string SFxChannelDispatcherDifferentHost0 = @"This ChannelDispatcher is not currently attached to the provided ServiceHost.";
public const string SFxChannelDispatcherMultipleHost0 = @"Cannot add a ChannelDispatcher to more than one ServiceHost.";
public const string SFxChannelDispatcherNoHost0 = @"Cannot open ChannelDispatcher because it is not attached to a ServiceHost.";
public const string SFxChannelDispatcherNoMessageVersion = @"Cannot open ChannelDispatcher because it is does not have a MessageVersion set.";
public const string SFxChannelDispatcherUnableToOpen1 = @"The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.";
public const string SFxChannelDispatcherUnableToOpen2 = @"The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.";
public const string SFxChannelFactoryTypeMustBeInterface = @"The type argument passed to the generic ChannelFactory class must be an interface type.";
public const string SFxChannelFactoryCannotApplyConfigurationWithoutEndpoint = @"ApplyConfiguration requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the ApplyConfiguration method to provide an alternative implementation.";
public const string SFxChannelFactoryCannotCreateFactoryWithoutDescription = @"CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.";
public const string SFxChannelTerminated0 = @"An operation marked as IsTerminating has already been invoked on this channel, causing the channel's connection to terminate.  No more operations may be invoked on this channel.  Please re-create the channel to continue communication.";
public const string SFxClientOutputSessionAutoClosed = @"This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.";
public const string SFxCodeGenArrayTypeIsNotSupported = @"Array of type {0} is not supported.";
public const string SFxCodeGenCanOnlyStoreIntoArgOrLocGot0 = @"Can only store into ArgBuilder or LocalBuilder. Got: {0}.";
public const string SFxCodeGenExpectingEnd = @"Expecting End {0}.";
public const string SFxCodeGenIsNotAssignableFrom = @"{0} is not assignable from {1}.";
public const string SFxCodeGenNoConversionPossibleTo = @"No conversion possible to {0}.";
public const string SFxCodeGenWarning = @"CODEGEN: {0}";
public const string SFxCodeGenUnknownConstantType = @"Internal Error: Unrecognized constant type {0}.";
public const string SFxCollectionDoesNotSupportSet0 = @"This collection does not support setting items by index.";
public const string SFxCollectionReadOnly = @"This operation is not supported because the collection is read-only.";
public const string SFxCollectionWrongType2 = @"The collection of type {0} does not support values of type {1}.";
public const string SFxConflictingGlobalElement = @"Top level XML element with name {0} in namespace {1} cannot reference {2} type because it already references a different type ({3}). Use a different operation name or MessageBodyMemberAttribute to specify a different name for the Message or Message parts.";
public const string SFxConflictingGlobalType = @"Duplicate top level XML Schema type with name {0} in namespace {1}.";
public const string SFxContextModifiedInsideScope0 = @"The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.";
public const string SFxContractDescriptionNameCannotBeEmpty = @"ContractDescription's Name must be a non-empty string.";
public const string SFxContractHasZeroOperations = @"ContractDescription '{0}' has zero operations; a contract must have at least one operation.";
public const string SFxContractHasZeroInitiatingOperations = @"ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.";
public const string SFxContractInheritanceRequiresInterfaces = @"The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.";
public const string SFxContractInheritanceRequiresInterfaces2 = @"The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.";
public const string SFxCopyToRequiresICollection = @"SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.";
public const string SFxCreateDuplexChannel1 = @"The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.";
public const string SFxCreateDuplexChannelNoCallback = @"This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.";
public const string SFxCreateDuplexChannelNoCallback1 = @"This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.";
public const string SFxCreateDuplexChannelNoCallbackUserObject = @"This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.";
public const string SFxCreateDuplexChannelBadCallbackUserObject = @"The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.";
public const string SFxCreateNonDuplexChannel1 = @"ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.";
public const string SFxCustomBindingNeedsTransport1 = @"The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.";
public const string SFxCustomBindingWithoutTransport = @"The Scheme cannot be computed for this binding because this CustomBinding lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.";
public const string SFxDeserializationFailed1 = @"The formatter threw an exception while trying to deserialize the message: {0}";
public const string SFxDictionaryIsEmpty = @"This operation is not possible since the dictionary is empty.";
public const string SFxDisallowedAttributeCombination = @"The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.";
public const string SFxInitializationUINotCalled = @"The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.";
public const string SFxInitializationUIDisallowed = @"AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.";
public const string SFxDocExt_NoMetadataSection1 = @"This is a Windows&#169; Communication Foundation service.<BR/><BR/><B>Metadata publishing for this service is currently disabled.</B><BR/><BR/>If you have access to the service, you can enable metadata publishing by completing the following steps to modify your web or application configuration file:<BR/><BR/>1. Create the following service behavior configuration, or add the &lt;serviceMetadata&gt; element to an existing service behavior configuration:";
public const string SFxDocExt_NoMetadataSection2 = @"2. Add the behavior configuration to the service:";
public const string SFxDocExt_NoMetadataSection3 = @"Note: the service name must match the configuration name for the service implementation.<BR/><BR/>3. Add the following endpoint to your service configuration:";
public const string SFxDocExt_NoMetadataSection4 = @"Note: your service must have an http base address to add this endpoint.<BR/><BR/>The following is an example service configuration file with metadata publishing enabled:";
public const string SFxDocExt_NoMetadataSection5 = @"For more information on publishing metadata please see the following documentation: <a href=""http://go.microsoft.com/fwlink/?LinkId=65455"">http://go.microsoft.com/fwlink/?LinkId=65455</a>.";
public const string SFxDocExt_NoMetadataConfigComment1 = @"Note: the service name must match the configuration name for the service implementation.";
public const string SFxDocExt_NoMetadataConfigComment2 = @"Add the following endpoint.";
public const string SFxDocExt_NoMetadataConfigComment3 = @"Note: your service must have an http base address to add this endpoint.";
public const string SFxDocExt_NoMetadataConfigComment4 = @"Add the following element to your service behavior configuration.";
public const string SFxDocExt_CS = @"<P class='intro'><B>C#</B></P>";
public const string SFxDocExt_VB = @"<P class='intro'><B>Visual Basic</B></P>";
public const string SFxDocExt_MainPageTitleNoServiceName = @"Service";
public const string SFxDocExt_MainPageTitle = @"{0} Service";
public const string SFxDocExt_MainPageIntro1a = @"You have created a service.<P class='intro'>To test this service, you will need to create a client and use it to call the service. You can do this using the svcutil.exe tool from the command line with the following syntax:</P>";
public const string SFxDocExt_MainPageIntro1b = @"You have created a service.<P class='intro'>To test this service, you will need to create a client and use it to call the service; however, metadata publishing via ?WSDL is currently disabled. This can be enabled via the service's configuration file. </P>";
public const string SFxDocExt_MainPageIntro2 = @"This will generate a configuration file and a code file that contains the client class. Add the two files to your client application and use the generated client class to call the Service. For example:<BR/>";
public const string SFxDocExt_MainPageComment = @"Use the 'client' variable to call operations on the service.";
public const string SFxDocExt_MainPageComment2 = @"Always close the client.";
public const string SFxDocExt_Error = @"The service encountered an error.";
public const string SFxDocEncodedNotSupported = @"Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.";
public const string SFxDuplicateMessageParts = @"Message part {0} in namespace {1} appears more than once in Message.";
public const string SFxDuplicateInitiatingActionAtSameVia = @"This service has multiple endpoints listening at '{0}' which share the same initiating action '{1}'.  As a result, messages with this action would be dropped since the dispatcher would not be able to determine the correct endpoint for handling the message.  Please consider hosting these Endpoints at separate ListenUris.";
public const string SFXEndpointBehaviorUsedOnWrongSide = @"The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.";
public const string SFxEndpointDispatcherMultipleChannelDispatcher0 = @"Cannot add EndpointDispatcher to more than one ChannelDispatcher.";
public const string SFxEndpointDispatcherDifferentChannelDispatcher0 = @"This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.";
public const string SFxErrorCreatingMtomReader = @"Error creating a reader for the MTOM message";
public const string SFxErrorDeserializingRequestBody = @"Error in deserializing body of request message for operation '{0}'.";
public const string SFxErrorDeserializingRequestBodyMore = @"Error in deserializing body of request message for operation '{0}'. {1}";
public const string SFxErrorDeserializingReplyBody = @"Error in deserializing body of reply message for operation '{0}'.";
public const string SFxErrorDeserializingReplyBodyMore = @"Error in deserializing body of reply message for operation '{0}'. {1}";
public const string SFxErrorSerializingBody = @"There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.";
public const string SFxErrorDeserializingHeader = @"There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.";
public const string SFxErrorSerializingHeader = @"There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.";
public const string SFxErrorDeserializingFault = @"Server returned an invalid SOAP Fault.  Please see InnerException for more details.";
public const string SFxErrorReflectingOnType2 = @"An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.";
public const string SFxErrorReflectingOnMethod3 = @"An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.";
public const string SFxErrorReflectingOnParameter4 = @"An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.";
public const string SFxErrorReflectionOnUnknown1 = @"An error occurred while loading attribute '{0}'.  Please see InnerException for more details.";
public const string SFxExceptionDetailEndOfInner = @"--- End of inner ExceptionDetail stack trace ---";
public const string SFxExceptionDetailFormat = @"An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:";
public const string SFxExpectedIMethodCallMessage = @"Internal Error: Message must be a valid IMethodCallMessage.";
public const string SFxExportMustHaveType = @"The specified ContractDescription could not be exported to WSDL because the Type property of the MessagePartDescription with name '{1}' in the OperationDescription with name '{0}' is not set.  The Type property must be set in order to create WSDL.";
public const string SFxFaultCannotBeImported = @"Fault named {0} in operation {1} cannot be imported. {2}";
public const string SFxFaultContractDuplicateDetailType = @"In operation {0}, more than one fault is declared with detail type {1}";
public const string SFxFaultContractDuplicateElement = @"In operation {0}, more than one fault is declared with element name {1} in namespace {2}";
public const string SFxFaultExceptionToString3 = @"{0}: {1} (Fault Detail is equal to {2}).";
public const string SFxFaultReason = @"The creator of this fault did not specify a Reason.";
public const string SFxFaultTypeAnonymous = @"In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.";
public const string SFxHeaderNameMismatchInMessageContract = @"Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribure or the member name.";
public const string SFxHeaderNameMismatchInOperation = @"Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribure or the member name.";
public const string SFxHeaderNamespaceMismatchInMessageContract = @"Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribure or the contract namespace.";
public const string SFxHeaderNamespaceMismatchInOperation = @"Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribure or the contract namespace.";
public const string SFxHeaderNotUnderstood = @"The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding.";
public const string SFxHeadersAreNotSupportedInEncoded = @"Message {0} must not have headers to be used in RPC encoded style.";
public const string SFxImmutableServiceHostBehavior0 = @"This value cannot be changed after the ServiceHost has opened.";
public const string SFxImmutableChannelFactoryBehavior0 = @"This value cannot be changed after the ChannelFactory has opened.";
public const string SFxImmutableThrottle1 = @"{0} cannot be changed after the ServiceHost has opened.";
public const string SFxInconsistentBindingBodyParts = @"Operation {0} binding {1} has extra part {2} that is not present in other bindings";
public const string SFxInconsistentWsdlOperationStyleInHeader = @"Style {1} on header {0} does not match expected style {2}.";
public const string SFxInconsistentWsdlOperationStyleInMessageParts = @"All parts of message in operation {0} must either contain type or element.";
public const string SFxInconsistentWsdlOperationStyleInOperationMessages = @"Style {1} inferred from messages in operation {0} does not match expected style {2} specified via bindings.";
public const string SFxInconsistentWsdlOperationUseAndStyleInBinding = @"Bindings for operation {0} cannot specify different use and style values. Binding {1} specifies use {2} and style {3} while binding {4} specifies use {5} and style {6}.";
public const string SFxInconsistentWsdlOperationUseInBindingExtensions = @"Extensions for operation {0} in binding {1} cannot specify different use values.";
public const string SFxInconsistentWsdlOperationUseInBindingMessages = @"Message bindings for operation {0} in binding {1} cannot specify different use values.";
public const string SFxInconsistentWsdlOperationUseInBindingFaults = @"Fault bindings for operation {0} in binding {1} cannot specify different use values.";
public const string SFxInputParametersToServiceInvalid = @"Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.";
public const string SFxInputParametersToServiceNull = @"Service implementation object invoked with null input parameters, but operation expects {0} parameters.";
public const string SFxInstanceNotInitialized = @"The InstanceContext has no provider for creating Service implementation objects.";
public const string SFxInterleavedContextScopes0 = @"This OperationContextScope is being disposed out of order.";
public const string SFxInternalServerError = @"The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the <serviceDebug> configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework 3.0 SDK documentation and inspect the server trace logs.";
public const string SFxInternalCallbackError = @"The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the <clientDebug> configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework 3.0 SDK documentation and inspect the client trace logs.";
public const string SFxInvalidAsyncResultState0 = @"IAsyncResult's State must be the state argument passed to your Begin call.";
public const string SFxInvalidCallbackIAsyncResult = @"IAsyncResult not provided or of wrong type.";
public const string SFxInvalidCallbackContractType = @"The CallbackContract {0} is invalid because it is not an interface type.";
public const string SFxInvalidChannelToOperationContext = @"Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.";
public const string SFxInvalidContextScopeThread0 = @"This OperationContextScope is being disposed on a different thread than it was created.";
public const string SFxInvalidMessageBody = @"OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'";
public const string SFxInvalidMessageBodyEmptyMessage = @"The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).";
public const string SFxInvalidMessageBodyErrorSerializingParameter = @"There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.";
public const string SFxInvalidMessageBodyErrorDeserializingParameter = @"There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.";
public const string SFxInvalidMessageBodyErrorDeserializingParameterMore = @"There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.";
public const string SFxInvalidMessageContractSignature = @"The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.";
public const string SFxInvalidMessageHeaderArrayType = @"MessageHeaderArrayAttribute found on member {0} is not a single dimensional array.";
public const string SFxInvalidRequestAction = @"Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.";
public const string SFxInvalidReplyAction = @"Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.";
public const string SFxInvalidStreamInTypedMessage = @"In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.";
public const string SFxInvalidStreamInRequest = @"For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.";
public const string SFxInvalidStreamInResponse = @"For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.";
public const string SFxInvalidStreamOffsetLength = @"Buffer size must be at least {0} bytes.";
public const string SFxInvalidUseOfPrimitiveOperationFormatter = @"The PrimitiveOperationFormatter was given a parameter or return type which it does not support.";
public const string SFxInvalidStaticOverloadCalledForDuplexChannelFactory1 = @"The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory<TChannel>.";
public const string SFxInvalidSoapAttribute = @"XmlSerializer attribute {0} is not valid in {1}. Only SoapElement attribute is supported.";
public const string SFxInvalidXmlAttributeInBare = @"XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.";
public const string SFxInvalidXmlAttributeInWrapped = @"XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.";
public const string SFxKnownTypeAttributeInvalid1 = @"{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type";
public const string SFxKnownTypeAttributeReturnType3 = @"The return type of method {1} in type {2} must be IEnumerable<Type> to be used by ServiceKnownTypeAttribute in {0}";
public const string SFxKnownTypeAttributeUnknownMethod3 = @"ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}";
public const string SFxKnownTypeNull = @"KnownType cannot be null in operation {0}";
public const string SFxMessageContractBaseTypeNotValid = @"The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.";
public const string SFxMessageContractRequiresDefaultConstructor = @"The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.";
public const string SFxMessageOperationFormatterCannotSerializeFault = @"MessageOperationFormatter cannot serialize faults.";
public const string SFxMetadataReferenceInvalidLocation = @"The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.";
public const string SFxMethodNotSupported1 = @"Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.";
public const string SFxMethodNotSupportedOnCallback1 = @"Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.";
public const string SFxMethodNotSupportedByType2 = @"ServiceHost implementation type {0} does not implement ServiceContract {1}.";
public const string SFxMismatchedOperationParent = @"A ClientOperation can only be added to its parent ClientRuntime.";
public const string SFxMissingActionHeader = @"No Action header was found with namespace '{0}' for the given message.";
public const string SFxMultipleCallbackFromSynchronizationContext = @"Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.";
public const string SFxMultipleCallbackFromAsyncOperation = @"The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.";
public const string SFxMultipleUnknownHeaders = @"Method {0} in type {1} has more than one header part of type array of XmlElement.";
public const string SFxMultipleContractStarOperations0 = @"A ServiceContract has more the one operation with an Action of ""*"".  A ServiceContract can have at most one operation an Action = ""*"".";
public const string SFxMultipleContractsWithSameName = @"The Service contains multiple ServiceEndpoints with different ContractDescriptions which each have Name='{0}' and Namespace='{1}'.  Either provide ContractDescriptions with unique Name and Namespaces, or ensure the ServiceEndpoints have the same ContractDescription instance.";
public const string SFxMultiplePartsNotAllowedInEncoded = @"Part {1}:{0} is repeating and is not supported in Soap Encoding.";
public const string SFxNameCannotBeEmpty = @"The Name property must be a non-empty string.";
public const string SFxConfigurationNameCannotBeEmpty = @"The ConfigurationName property must be a non-empty string.";
public const string SFxNeedProxyBehaviorOperationSelector2 = @"Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.";
public const string SFxNoDefaultConstructor = @"The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.";
public const string SFxNoMostDerivedContract = @"The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.";
public const string SFxNullReplyFromExtension2 = @"Extension {0} prevented call to operation '{1}' from replying by setting the reply to null.";
public const string SFxNullReplyFromFormatter2 = @"Formatter {0} returned a null reply message for call to operation '{1}'.";
public const string SFxServiceChannelIdleAborted = @"The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.";
public const string SFxServiceMetadataBehaviorUrlMustBeHttpOrRelative = @"{0} must be a relative URI or an absolute URI with scheme '{1}'.  '{2}' is an absolute URI with scheme '{3}'.";
public const string SFxServiceMetadataBehaviorNoHttpBaseAddress = @"The HttpGetEnabled property of ServiceMetadataBehavior is set to true and the HttpGetUrl property is a relative address, but there is no http base address.  Either supply an http base address or set HttpGetUrl to an absolute address.";
public const string SFxServiceMetadataBehaviorNoHttpsBaseAddress = @"The HttpsGetEnabled property of ServiceMetadataBehavior is set to true and the HttpsGetUrl property is a relative address, but there is no https base address.  Either supply an https base address or set HttpsGetUrl to an absolute address.";
public const string SFxServiceMetadataBehaviorInstancingError = @"The ChannelDispatcher with ListenUri '{0}' has endpoints with the following contracts: {1}. Metadata endpoints cannot share ListenUris. The conflicting endpoints were either specified in AddServiceEndpoint() calls, in a config file, or a combination of AddServiceEndpoint() and config.";
public const string SFxServiceTypeNotCreatable = @"Service implementation type is an interface or abstract class and no implementation object was provided.";
public const string SFxSetEnableFaultsOnChannelDispatcher0 = @"This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.";
public const string SFxSetManualAddresssingOnChannelDispatcher0 = @"This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.";
public const string SFxNoBatchingForSession = @"TransactedBatchingBehavior validation failed. Service or client cannot be started. Transacted batching is not supported for session contracts. Remove transacted batching behavior from the endpoint or define a non-sessionful contract.";
public const string SFxNoBatchingForReleaseOnComplete = @"TransactedBatchingBehavior validation failed. Service cannot be started. Transacted batching requires ServiceBehavior.ReleaseServiceInstanceOnTransactionComplete to be false.";
public const string SFxNoServiceObject = @"The service implementation object was not initialized or is not available.";
public const string SFxNone2004 = @"The WS-Addressing ""none"" value is not valid for the August 2004 version of WS-Addressing.";
public const string SFxNonExceptionThrown = @"An object that is not an exception was thrown.";
public const string SFxNonInitiatingOperation1 = @"The operation '{0}' cannot be the first operation to be called because IsInitiating is false.";
public const string SfxNoTypeSpecifiedForParameter = @"There was no CLR type specified for parameter {0}, preventing the operation from being generated.";
public const string SFxOneWayAndTransactionsIncompatible = @"The one-way operation '{1}' on ServiceContract '{0}' is configured for transaction flow. Transactions cannot be flowed over one-way operations.";
public const string SFxOneWayMessageToTwoWayMethod0 = @"The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.";
public const string SFxOperationBehaviorAttributeOnlyOnServiceClass = @"OperationBehaviorAttribute can only go on the service class, it cannot be put on the ServiceContract interface. Method '{0}' on type '{1}' violates this.";
public const string SFxOperationBehaviorAttributeReleaseInstanceModeDoesNotApplyToCallback = @"The ReleaseInstanceMode property on OperationBehaviorAttribute can only be set on non-callback operations. Method '{0}' violates this.";
public const string SFxOperationContractOnNonServiceContract = @"Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.";
public const string SFxOperationDescriptionNameCannotBeEmpty = @"OperationDescription's Name must be a non-empty string.";
public const string SFxOperationMustHaveOneOrTwoMessages = @"OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.";
public const string SFxParameterCountMismatch = @"There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.";
public const string SFxParameterMustBeMessage = @"The 'parameters' argument must be an array that contains a single Message object.";
public const string SFxParametersMustBeEmpty = @"The 'parameters' argument must be either null or an empty array.";
public const string SFxParameterMustBeArrayOfOneElement = @"The 'parameters' argument must be an array of one element.";
public const string SFxPartNameMustBeUniqueInRpc = @"Message part name {0} is not unique in an RPC Message.";
public const string SFxRequestHasInvalidReplyToOnClient = @"The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.";
public const string SFxRequestHasInvalidFaultToOnClient = @"The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.";
public const string SFxRequestHasInvalidFromOnClient = @"The request message has From='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting From on the message.";
public const string SFxRequestHasInvalidReplyToOnServer = @"The request message has ReplyTo='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.";
public const string SFxRequestHasInvalidFaultToOnServer = @"The request message has FaultTo='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.";
public const string SFxRequestHasInvalidFromOnServer = @"The request message has From='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.";
public const string SFxRequestReplyNone = @"A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the ""None"" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of ""None.""";
public const string SFxRequestTimedOut1 = @"This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.";
public const string SFxRequestTimedOut2 = @"This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.";
public const string SFxReplyActionMismatch3 = @"A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.";
public const string SFxRequiredRuntimePropertyMissing = @"Required runtime property '{0}' is not initialized on DispatchRuntime. Do not remove ServiceBehaviorAttribute from ServiceDescription.Behaviors or ensure that you include a third-party service behavior that supplies this value.";
public const string SFxResolvedMaxResolvedReferences = @"The MetadataExchangeClient has resolved more than MaximumResolvedReferences.";
public const string SFxResultMustBeMessage = @"The 'result' argument must be of type Message.";
public const string SFxRevertImpersonationFailed0 = @"Could not revert impersonation on current thread. Continuing would compromise system security. Terminating process.";
public const string SFxRpcMessageBodyPartNameInvalid = @"RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}";
public const string SFxRpcMessageMustHaveASingleBody = @"RPC Message {1} in operation {0} must have a single MessageBodyMember.";
public const string SFxSchemaDoesNotContainElement = @"There was a problem loading the XSD documents provided: a reference to a schema element with name '{0}' and namespace '{1}' could not be resolved because the element definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.";
public const string SFxSchemaDoesNotContainType = @"There was a problem loading the XSD documents provided: a reference to a schema type with name '{0}' and namespace '{1}' could not be resolved because the type definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.";
public const string SFxWsdlMessageDoesNotContainPart3 = @"Service description message '{1}' from target namespace '{2}' does not contain part named '{0}'.";
public const string SFxSchemaNotFound = @"Schema with target namespace '{0}' could not be found.";
public const string SFxSecurityContextPropertyMissingFromRequestMessage = @"SecurityContextProperty is missing from the request Message, this may indicate security is configured incorrectly.";
public const string SFxServerDidNotReply = @"The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.";
public const string SFxServiceHostBaseCannotAddEndpointAfterOpen = @"Endpoints cannot be added after the ServiceHost has been opened/faulted/aborted/closed.";
public const string SFxServiceHostBaseCannotAddEndpointWithoutDescription = @"Endpoints cannot be added before the Description property has been initialized.";
public const string SFxServiceHostBaseCannotApplyConfigurationWithoutDescription = @"ApplyConfiguration requires that the Description property be initialized. Either provide a valid ServiceDescription in the CreateDescription method or override the ApplyConfiguration method to provide an alternative implementation.";
public const string SFxServiceHostBaseCannotLoadConfigurationSectionWithoutDescription = @"LoadConfigurationSection requires that the Description property be initialized. Provide a valid ServiceDescription in the CreateDescription method.";
public const string SFxServiceHostBaseCannotInitializeRuntimeWithoutDescription = @"InitializeRuntime requires that the Description property be initialized. Either provide a valid ServiceDescription in the CreateDescription method or override the InitializeRuntime method to provide an alternative implementation.";
public const string SFxServiceHostCannotCreateDescriptionWithoutServiceType = @"InitializeDescription must be called with a serviceType or singletonInstance parameter.";
public const string SFxStaticMessageHeaderPropertiesNotAllowed = @"Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader<T>.";
public const string SFxStreamIOException = @"An exception has been thrown when reading the stream.";
public const string SFxStreamRequestMessageClosed = @"The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.";
public const string SFxStreamResponseMessageClosed = @"The message containing this stream has been closed.";
public const string SFxTerminatingOperationAlreadyCalled1 = @"This channel cannot send any more messages because IsTerminating operation '{0}' has already been called.";
public const string SFxThrottleLimitMustBeGreaterThanZero0 = @"Throttle limit must be greater than zero. To disable, set to Int32.MaxValue.";
public const string SFxTimeoutInvalidStringFormat = @"The timeout value provided was not of a recognized format.  Please see InnerException for more details.";
public const string SFxTimeoutOutOfRange0 = @"Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.";
public const string SFxTimeoutOutOfRangeTooBig = @"Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.";
public const string SFxTooManyPartsWithSameName = @"Cannot create a unique part name for {0}.";
public const string SFxTraceCodeElementIgnored = @"An unrecognized element was encountered in the XML during deserialization which was ignored.";
public const string SFxTransactionAutoEnlistOrAutoComplete2 = @"The operation '{1}' on contract '{0}' is configured with TransactionAutoComplete set to true and with TransactionScopeRequired set to false. TransactionAutoComplete requires that TransactionScopeRequired is set to true.";
public const string SfxTransactedBindingNeeded = @"TransactedBatchingBehavior validation failed. The service endpoint cannot be started. TransactedBatchingBehavior requires a binding that contains a binding element ITransactedBindingElement that returns true for ITransactedBindingElement.TransactedReceiveEnabled. If you are using NetMsmqBinding or MsmqIntegrationBinding make sure that ExactlyOnce is set to true.";
public const string SFxTransactionNonConcurrentOrAutoComplete2 = @"TThe operation '{1}' on contract '{0}' is configured with TransactionAutoComplete set to false and with ConcurrencyMode not set to Single. TransactionAutoComplete set to false requires ConcurrencyMode.Single.";
public const string SFxTransactionNonConcurrentOrReleaseServiceInstanceOnTxComplete = @"The '{0}' service is configured with ReleaseServiceInstanceOnTransactionComplete set to true, but the ConcurrencyMode is not set to Single. The ReleaseServiceInstanceOnTransactionComplete requires the use of ConcurrencyMode.Single.";
public const string SFxTransactionsNotSupported = @"The service does not support concurrent transactions.";
public const string SFxTransactionAsyncAborted = @"The transaction under which this method call was executing was asynchronously aborted.";
public const string SFxTransactionInvalidSetTransactionComplete = @"The SetTransactionComplete method was called in the operation '{0}' on contract '{1}' when TransactionAutoComplete was set to true. The SetTransactionComplete method can only be called when TransactionAutoComplete is set to false. This is an invalid scenario and the current transaction was aborted.";
public const string SFxMultiSetTransactionComplete = @"The SetTransactionComplete method was wrongly called more than once in the operation '{0}' on contract '{1}'. The SetTransactionComplete method can only be called once. This is an invalid scenario and the current transaction was aborted.";
public const string SFxTransactionFlowAndMSMQ = @"The binding for the endpoint at address '{0}' is configured with both the MsmqTransportBindingElement and the TransactionFlowBindingElement. These two elements cannot be used together.";
public const string SFxTransactionAutoCompleteFalseAndInstanceContextMode = @"The operation '{1}' on contract '{0}' is configured with TransactionAutoComplete set to false and the InstanceContextMode is not set to PerSession. TransactionAutoComplete set to false requires the use of InstanceContextMode.PerSession.";
public const string SFxTransactionAutoCompleteFalseOnCallbackContract = @"The operation '{0}' on callback contract '{1}' is configured with TransactionAutoComplete set to false. TransactionAutoComplete set to false cannot be used with operations on callback contracts.";
public const string SFxTransactionAutoCompleteFalseAndSupportsSession = @"The operation '{1}' on contract '{0}' is configured with TransactionAutoComplete set to false but SessionMode is not set to Required. TransactionAutoComplete set to false requires SessionMode.Required.";
public const string SFxTransactionAutoCompleteOnSessionCloseNoSession = @"The service '{0}' is configured with TransactionAutoCompleteOnSessionClose set to true and with an InstanceContextMode not set to PerSession. TransactionAutoCompleteOnSessionClose set to true requires an instancing mode that uses sessions.";
public const string SFxTransactionTransactionTimeoutNeedsScope = @"The service '{0}' is configured with a TransactionTimeout but no operations are configured with TransactionScopeRequired set to true. TransactionTimeout requires at least one operation with TransactionScopeRequired set to true.";
public const string SFxTransactionIsolationLevelNeedsScope = @"The service '{0}' is configured with a TransactionIsolationLevel but no operations are configured with TransactionScopeRequired set to true. TransactionIsolationLevel requires at least one operation with TransactionScopeRequired set to true.";
public const string SFxTransactionReleaseServiceInstanceOnTransactionCompleteNeedsScope = @"The service '{0}' is configured with ReleaseServiceInstanceOnTransactionComplete set to true but no operations are configured with TransactionScopeRequired set to true. ReleaseServiceInstanceOnTransactionComplete requires at least one operation with TransactionScopeRequired set to true.";
public const string SFxTransactionTransactionAutoCompleteOnSessionCloseNeedsScope = @"The service '{0}' is configured with TransactionAutoCompleteOnSessionClose set to true, but no operations are configured with TransactionScopeRequired set to true. TransactionAutoCompleteOnSessionClose requires at least one operation with TransactionScopeRequired set to true.";
public const string SFxTransactionFlowRequired = @"The service operation requires a transaction to be flowed.";
public const string SFxTransactionUnmarshalFailed = @"The flowed transaction could not be unmarshaled. The following exception occurred: {0}";
public const string SFxTransactionDeserializationFailed = @"The incoming transaction cannot be deserialized. The transaction header in the message was either malformed or in an unrecognized format. The client and the service must be configured to use the same protocol and protocol version. The following exception occurred: {0}";
public const string SFxTransactionHeaderNotUnderstood = @"The transaction header '{0}' within the namespace '{1}' was not understood by the service. The client and the service must be configured to use the same protocol and protocol version ('{2}').";
public const string SFxTryAddMultipleTransactionsOnMessage = @"An attempt was made to add more than one transaction to a message. At most one transaction can be added.";
public const string SFxTypedMessageCannotBeNull = @"Internal Error: The instance of the MessageContract cannot be null in {0}.";
public const string SFxTypedMessageCannotBeRpcLiteral = @"The operation '{0}' could not be loaded because it specifies ""rpc-style"" in ""literal"" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.";
public const string SFxTypedOrUntypedMessageCannotBeMixedWithParameters = @"The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.";
public const string SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc = @"When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.";
public const string SFxUnknownFaultNoMatchingTranslation1 = @"This fault did not provide a matching translation: {0}";
public const string SFxUnknownFaultNullReason0 = @"This fault did not provide a reason (MessageFault.Reason was null).";
public const string SFxUnknownFaultZeroReasons0 = @"This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).";
public const string SFxUserCodeThrewException = @"User operation '{0}.{1}' threw an exception that is unhandled in user code. This exception will be rethrown. If this is a recurring problem, it may indicate an error in the implementation of the '{0}.{1}' method.";
public const string SfxUseTypedMessageForCustomAttributes = @"Parameter '{0}' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is '{1}'.";
public const string SFxWellKnownNonSingleton0 = @"In order to use one of the ServiceHost constructors that takes a service instance, the InstanceContextMode of the service must be set to InstanceContextMode.Single.  This can be configured via the ServiceBehaviorAttribute.  Otherwise, please consider using the ServiceHost constructors that take a Type argument.";
public const string SFxVersionMismatchInOperationContextAndMessage2 = @"Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.";
public const string SFxWhenMultipleEndpointsShareAListenUriTheyMustHaveSameIdentity = @"When multiple endpoints on a service share the same ListenUri, those endpoints must all have the same Identity in their EndpointAddress. The endpoints at ListenUri '{0}' do not meet this criteria.";
public const string SFxWrapperNameCannotBeEmpty = @"Wrapper element name cannot be empty.";
public const string SFxWrapperTypeHasMultipleNamespaces = @"Wrapper type for message {0} cannot be projected as a data contract type since it has multiple namespaces. Consider using the XmlSerializer";
public const string SFxWrongType2 = @"An argument of the wrong type was passed to this method.  This method expected an argument of type {0}, but it was passed an argument of type {1}.";
public const string SFxWsdlPartMustHaveElementOrType = @"WSDL part {0} in message {1} from namespace {2} must have either an element or a type name";
public const string SFxDataContractSerializerDoesNotSupportBareArray = @"DataContractSerializer does not support collection specified on element '{0}'";
public const string SFxDataContractSerializerDoesNotSupportEncoded = @"Invalid OperationFormatUse specified in the OperationFormatStyle of operation {0}, DataContractSerializer supports only Literal.";
public const string SFxXmlArrayNotAllowedForMultiple = @"XmlArrayAttribute cannot be used in repeating part {1}:{0}.";
public const string SFxConfigContractNotFound = @"Could not find default endpoint element that references contract '{0}' in the ServiceModel client configuration section. This might be because no configuration file was found for your application, or because no endpoint element matching this contract could be found in the client element.";
public const string SFxConfigChannelConfigurationNotFound = @"Could not find endpoint element with name '{0}' and contract '{1}' in the ServiceModel client configuration section. This might be because no configuration file was found for your application, or because no endpoint element matching this name could be found in the client element.";
public const string SFxChannelFactoryEndpointAddressUri = @"The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.";
public const string SFxServiceContractGeneratorConfigRequired = @"In order to generate configuration information using the GenerateServiceEndpoint method, the ServiceContractGenerator instance must have been initialized with a valid Configuration object.";
public const string SFxCloseTimedOut1 = @"The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.";
public const string SfxCloseTimedOutWaitingForDispatchToComplete = @"Close process timed out waiting for service dispatch to complete.";
public const string SFxInvalidWsdlBindingOpMismatch2 = @"The WSDL binding named {0} is not valid because no match for operation {1} was found in the corresponding portType definition.";
public const string SFxInvalidWsdlBindingOpNoName = @"The WSDL binding named {0} is not valid because an operation binding doesn't have a name specified.";
public const string SFxChannelFactoryNoBindingFoundInConfig1 = @"The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.";
public const string SFxChannelFactoryNoBindingFoundInConfigOrCode = @"The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.";
public const string SFxConfigLoaderMultipleEndpointMatchesSpecified2 = @"The endpoint configuration section for contract '{0}' with name '{1}' could not be loaded because more than one endpoint configuration with the same name and contract were found. Please check your config and try again.";
public const string SFxConfigLoaderMultipleEndpointMatchesWildcard1 = @"An endpoint configuration section for contract '{0}' could not be loaded because more than one endpoint configuration for that contract was found. Please indicate the preferred endpoint configuration section by name.";
public const string SFxProxyRuntimeMessageCannotBeNull = @"In operation '{0}', cannot pass null to methods that take Message as input parameter.";
public const string SFxDispatchRuntimeMessageCannotBeNull = @"In operation '{0}', cannot return null from methods that return Message.";
public const string SFxServiceHostNeedsClass = @"ServiceHost only supports class service types.";
public const string SfxReflectedContractKeyNotFound2 = @"The contract name '{0}' could not be found in the list of contracts implemented by the service '{1}'.";
public const string SfxReflectedContractKeyNotFoundEmpty = @"In order to add an endpoint to the service '{0}', a non-empty contract name must be specified.";
public const string SfxReflectedContractKeyNotFoundIMetadataExchange = @"The contract name 'IMetadataExchange' could not be found in the list of contracts implemented by the service {0}.  Add a ServiceMetadataBehavior to the configuration file or to the ServiceHost directly to enable support for this contract.";
public const string SfxServiceContractAttributeNotFound = @"The contract type {0} is not attributed with ServiceContractAttribute.  In order to define a valid contract, the specified type (either contract interface or service class) must be attributed with ServiceContractAttribute.";
public const string SfxReflectedContractsNotInitialized1 = @"An endpoint for type '{0}' could not be added because the ServiceHost instance was not initialized properly.  In order to add endpoints by Type, the CreateDescription method must be called.  If you are using a class derived from ServiceHost, ensure that the class is properly calling base.CreateDescription.";
public const string SFxMessagePartDescriptionMissingType = @"Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.";
public const string SFxWsdlOperationInputNeedsMessageAttribute2 = @"The wsdl operation input {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.";
public const string SFxWsdlOperationOutputNeedsMessageAttribute2 = @"The wsdl operation output {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.";
public const string SFxWsdlOperationFaultNeedsMessageAttribute2 = @"The wsdl operation {0} in portType {1} contains a fault that does not reference a message. This is either because the message attribute is missing or empty.";
public const string SFxMessageContractAttributeRequired = @"Cannot create a typed message from type '{0}'.  The functionality only valid for types decorated with MessageContractAttribute.";
public const string AChannelServiceEndpointIsNull0 = @"A Channel/Service Endpoint is null.";
public const string AChannelServiceEndpointSBindingIsNull0 = @"A Channel endpoint's Binding is null.";
public const string AChannelServiceEndpointSContractIsNull0 = @"A Channel endpoint's Contract is null.";
public const string AChannelServiceEndpointSContractSNameIsNull0 = @"A Channel/Service endpoint's Contract's name is null or empty.";
public const string AChannelServiceEndpointSContractSNamespace0 = @"A Channel/Service endpoint's Contract's namespace is null.";
public const string ServiceHasZeroAppEndpoints = @"Service '{0}' has zero application (non-infrastructure) endpoints. This might be because no configuration file was found for your application, or because no service element matching the service name could be found in the configuration file, or because no endpoints were defined in the service element.";
public const string BindingRequirementsAttributeRequiresQueuedDelivery1 = @"DeliveryRequirementsAttribute requires QueuedDelivery, but binding for the endpoint with contract '{0}' doesn't support it or isn't configured properly to support it.";
public const string BindingRequirementsAttributeDisallowsQueuedDelivery1 = @"DeliveryRequirementsAttribute disallows QueuedDelivery, but binding for the endpoint with contract '{0}' supports it.";
public const string SinceTheBindingForDoesnTSupportIBindingCapabilities1_1 = @"The DeliveryRequirementsAttribute on contract '{0}' specifies that the binding must support ordered delivery (RequireOrderedDelivery).  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.";
public const string SinceTheBindingForDoesnTSupportIBindingCapabilities2_1 = @"The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements constraint.  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.";
public const string TheBindingForDoesnTSupportOrderedDelivery1 = @"The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements value of NotAllowed.  However, the configured binding for this contract specifies that it does support queued delivery.  A queued binding may not be used with this contract.";
public const string ChannelHasAtLeastOneOperationWithTransactionFlowEnabled = @"At least one operation on the '{0}' contract is configured with the TransactionFlowAttribute attribute set to Mandatory but the channel's binding '{1}' is not configured with a TransactionFlowBindingElement. The TransactionFlowAttribute attribute set to Mandatory cannot be used without a TransactionFlowBindingElement.";
public const string ServiceHasAtLeastOneOperationWithTransactionFlowEnabled = @"At least one operation on the '{0}' contract is configured with the TransactionFlowAttribute attribute set to Mandatory but the channel's binding '{1}' is not configured with a TransactionFlowBindingElement. The TransactionFlowAttribute attribute set to Mandatory cannot be used without a TransactionFlowBindingElement.";
public const string SFxNoEndpointMatchingContract = @"The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).";
public const string SFxNoEndpointMatchingAddress = @"The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.";
public const string EndMethodsCannotBeDecoratedWithOperationContractAttribute = @"When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.";
public const string WsatMessagingInitializationFailed = @"The WS-AT messaging library failed to initialize.";
public const string WsatProxyCreationFailed = @"A client-side channel to the WS-AT protocol service could not be created.";
public const string DispatchRuntimeRequiresFormatter0 = @"The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.";
public const string ClientRuntimeRequiresFormatter0 = @"The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.";
public const string RuntimeRequiresInvoker0 = @"DispatchOperation requires Invoker.";
public const string CouldnTCreateChannelForType2 = @"Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.";
public const string CouldnTCreateChannelForChannelType2 = @"Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.";
public const string EndpointListenerRequirementsCannotBeMetBy3 = @"ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.";
public const string UnknownListenerType1 = @"The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.";
public const string BindingDoesnTSupportSessionButContractRequires1 = @"Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.";
public const string BindingDoesntSupportDatagramButContractRequires = @"Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.";
public const string BindingDoesnTSupportOneWayButContractRequires1 = @"Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.";
public const string BindingDoesnTSupportTwoWayButContractRequires1 = @"Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.";
public const string BindingDoesnTSupportRequestReplyButContract1 = @"Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.";
public const string BindingDoesnTSupportDuplexButContractRequires1 = @"Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.";
public const string BindingDoesnTSupportAnyChannelTypes1 = @"Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.";
public const string ContractIsNotSelfConsistentItHasOneOrMore2 = @"The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.";
public const string InstanceSettingsMustHaveTypeOrWellKnownObject0 = @"The ServiceHost must be configured with either a serviceType or a serviceInstance.  Both of these values are currently null.";
public const string TheServiceMetadataExtensionInstanceCouldNot2_0 = @"The ServiceMetadataExtension instance could not be added to the ServiceHost instance because it has already been added to another ServiceHost instance.";
public const string TheServiceMetadataExtensionInstanceCouldNot3_0 = @"The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has not been added to any ServiceHost instance.";
public const string TheServiceMetadataExtensionInstanceCouldNot4_0 = @"The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has already been added to a different ServiceHost instance.";
public const string SynchronizedCollectionWrongType1 = @"A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.";
public const string SynchronizedCollectionWrongTypeNull = @"A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.";
public const string CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0 = @"Cannot add two items with the same key to SynchronizedKeyedCollection.";
public const string ItemDoesNotExistInSynchronizedKeyedCollection0 = @"Item does not exist in SynchronizedKeyedCollection.";
public const string SuppliedMessageIsNotAReplyItHasNoRelatesTo0 = @"A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.";
public const string channelIsNotAvailable0 = @"Internal Error: The InnerChannel property is null.";
public const string channelDoesNotHaveADuplexSession0 = @"The current channel does not support closing the output session as this channel does not implement ISessionChannel<IDuplexSession>.";
public const string EndpointsMustHaveAValidBinding1 = @"The ServiceEndpoint with name '{0}' could not be exported to WSDL because the Binding property is null. To fix this, set the Binding property to a valid Binding instance.";
public const string ABindingInstanceHasAlreadyBeenAssociatedTo1 = @"A binding instance has already been associated to listen URI '{0}'. If two endpoints want to share the same ListenUri, they must also share the same binding object instance. The two conflicting endpoints were either specified in AddServiceEndpoint() calls, in a config file, or a combination of AddServiceEndpoint() and config.";
 



public const string UnabletoImportPolicy = @"The following Policy Assertions were not Imported:\r\n";
public const string UnImportedAssertionList = @"   XPath:{0}\r\n  Assertions:";
public const string XPathUnavailable = @"""XPath Unavailable""";
public const string DuplicatePolicyInWsdlSkipped = @"A policy expression was ignored because another policy expression with that ID has already been read in this document.\r\nXPath:{0}";
public const string DuplicatePolicyDocumentSkipped = @"A policy document was ignored because a policy expression with that ID has already been imported.\r\nPolicy ID:{0}";
public const string PolicyDocumentMustHaveIdentifier = @"A metadata section containing policy did not have an identifier so it cannot be referenced.";
public const string XPathPointer = @"XPath:{0}";
public const string UnableToFindPolicyWithId = @"A policy reference was ignored because the policy with ID '{0}' could not be found.";
public const string PolicyReferenceInvalidId = @"A policy reference was ignored because the URI of the reference was empty.";
public const string PolicyReferenceMissingURI = @"A policy reference was ignored because the required {0} attribute was missing.";
public const string ExceededMaxPolicyComplexity = @"The policy expression was not fully imported because it exceeded the maximum allowable complexity. The import stopped at element '{0}' '{1}'.";
public const string ExceededMaxPolicySize = @"The policy expression was not fully imported because its normalized form was too large.";
public const string UnrecognizedPolicyElementInNamespace = @"Unrecognized policy element {0} in namespace {1}.";
public const string UnsupportedPolicyDocumentRoot = @"""{0}"" is not a supported WS-Policy document root element.";
public const string UnrecognizedPolicyDocumentNamespace = @"The ""{0}"" namespace is not a recognized WS-Policy namespace.";
public const string NoUsablePolicyAssertions = @"Cannot find usable policy alternatives.";
public const string PolicyInWsdlMustHaveFragmentId = @"Unreachable policy detected.\r\nA WS-Policy element embedded in WSDL is missing a fragment identifier. This policy cannot be referenced by any WS-PolicyAttachment mechanisms.\r\nXPath:{0}";
public const string FailedImportOfWsdl = @"The processing of the WSDL parameter failed. Error: {0}";
public const string OptionalWSDLExtensionIgnored = @"The optional WSDL extension element '{0}' from namespace '{1}' was not handled.\r\nXPath: {2}";
public const string RequiredWSDLExtensionIgnored = @"The required WSDL extension element '{0}' from namespace '{1}' was not handled.";
public const string UnknownWSDLExtensionIgnored = @"An unrecognized WSDL extension of Type '{0}' was not handled.";
public const string WsdlExporterIsFaulted = @"A previous call to this WsdlExporter left it in a faulted state. It is no longer usable.";
public const string WsdlImporterIsFaulted = @"A previous call to this WsdlImporter left it in a faulted state. It is no longer usable.";
public const string WsdlImporterContractMustBeInKnownContracts = @"The ContractDescription argument to ImportEndpoints must be contained in the KnownContracts collection.";
public const string WsdlItemAlreadyFaulted = @"A previous attempt to import this {0} already failed.";
public const string InvalidPolicyExtensionTypeInConfig = @"The type {0} registered as a policy extension does not implement IPolicyImportExtension";
public const string PolicyExtensionTypeRequiresDefaultConstructor = @"The type {0} registered as a policy extension does not have a public default constructor. Policy extensions must have a public default constructor";
public const string PolicyExtensionImportError = @"An exception was thrown in a call to a policy import extension.\r\nExtension: {0}\r\nError: {1}";
public const string PolicyExtensionExportError = @"An exception was thrown in a call to a policy export extension.\r\nExtension: {0}\r\nError: {1}";
public const string MultipleCallsToExportContractWithSameContract = @"Calling IWsdlExportExtension.ExportContract twice with the same ContractDescription is not supported.";
public const string DuplicateContractQNameNameOnExport = @"Duplicate contract XmlQualifiedNames are not supported.\r\nAnother ContractDescription with the Name: {0} and Namespace: {1} has already been exported.";
public const string WarnDuplicateBindingQNameNameOnExport = @"Similar ServiceEndpoints were exported. The WSDL export process was forced to suffix wsdl:binding names to avoid naming conflicts.\r\n Similar ServiceEndpoints means different binding instances having the Name: {0} and Namespace: {1} and either the same ContractDescription or at least the same contract Name: {2}.";
public const string WarnSkippingOprtationWithWildcardAction = @"An operation was skipped during export because it has a wildcard action. This is not supported in WSDL.\r\nContract Name:{0}\r\nContract Namespace:{1}\r\nOperation Name:{2}";
public const string InvalidWsdlExtensionTypeInConfig = @"The type {0} registered as a WSDL extension does not implement IWsdlImportExtension.";
public const string WsdlExtensionTypeRequiresDefaultConstructor = @"The type {0} registered as a WSDL extension does not have a public default constructor. WSDL extensions must have a public default constructor.";
public const string WsdlExtensionContractExportError = @"An exception was thrown in a call to a WSDL export extension: {0}\r\n contract: {1}";
public const string WsdlExtensionEndpointExportError = @"An exception was thrown in a call to a WSDL export extension: {0}\r\n Endpoint: {1}";
public const string WsdlExtensionBeforeImportError = @"A WSDL import extension threw an exception during the BeforeImport call: {0}\r\nError: {1}";
public const string WsdlExtensionImportError = @"An exception was thrown while running a WSDL import extension: {0}\r\nError: {1}";
public const string WsdlImportErrorMessageDetail = @"Cannot import {0}\r\nDetail: {2}\r\nXPath to Error Source: {1}";
public const string WsdlImportErrorDependencyDetail = @"There was an error importing a {0} that the {1} is dependent on.\r\nXPath to {0}: {2}";
public const string UnsupportedEnvelopeVersion = @"The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.";
public const string NoValue0 = @"No value.";
public const string UnsupportedBindingElementClone = @"The '{0}' binding element does not support cloning.";
public const string UnrecognizedBindingAssertions1 = @"WsdlImporter encountered unrecognized policy assertions in ServiceDescription '{0}':";

public const string ServicesWithoutAServiceContractAttributeCan2 = @"The OperationContractAttribute declared on method '{0}' in type '{1}' is invalid. OperationContractAttributes are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{1}' or remove OperationContractAttribute from method '{0}'.";
public const string tooManyAttributesOfTypeOn2 = @"Too many attributes of type {0} on {1}.";
public const string couldnTFindRequiredAttributeOfTypeOn2 = @"Couldn't find required attribute of type {0} on {1}.";
public const string AttemptedToGetContractTypeForButThatTypeIs1 = @"Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.";
public const string NoEndMethodFoundForAsyncBeginMethod3 = @"OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.";
public const string MoreThanOneEndMethodFoundForAsyncBeginMethod3 = @"OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.";
public const string InvalidAsyncEndMethodSignatureForMethod2 = @"Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.";
public const string InvalidAsyncBeginMethodSignatureForMethod2 = @"Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.";
public const string InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo = @"Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.";
public const string InAContractInheritanceHierarchyTheServiceContract3_2 = @"In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.";
public const string CannotHaveTwoOperationsWithTheSameName3 = @"Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.";
public const string CannotHaveTwoOperationsWithTheSameElement5 = @"The {0}.{1} operation references a message element [{2}] that has already been exported from the {3}.{4} operation. You can change the name of one of the operations by changing the method name or using the Name property of OperationContractAttribute. Alternatively, you can control the element name in greater detail using the MessageContract programming model.";
public const string CannotInheritTwoOperationsWithTheSameName3 = @"Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.";
public const string SyncAsyncMatchConsistency_Parameters5 = @"The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.";
public const string SyncAsyncMatchConsistency_ReturnType5 = @"The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching.";
public const string SyncAsyncMatchConsistency_Attributes6 = @"The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching.";
public const string SyncAsyncMatchConsistency_Property6 = @"The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching.";
public const string ServiceOperationsMarkedWithIsOneWayTrueMust0 = @"Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.";
public const string OneWayOperationShouldNotSpecifyAReplyAction1 = @"One way operation {0} cannot not specify a reply action.";
public const string OneWayAndFaultsIncompatible2 = @"The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.";
public const string OnlyMalformedMessagesAreSupported = @"Only malformed Messages are supported.";
public const string UnableToLocateOperation2 = @"Cannot locate operation {0} in Contract {1}.";
public const string UnsupportedWSDLOnlyOneMessage = @"Unsupported WSDL, only one message part is supported for fault messages. This fault message references zero or more than one message part. If you have edit access to the WSDL file, you can fix the problem by removing the extra message parts such that fault message references just one part.";
public const string UnsupportedWSDLTheFault = @"Unsupported WSDL, the fault message part must reference an element. This fault message does not reference an element. If you have edit access to the WSDL document, you can fix the problem by referencing a schema element using the 'element' attribute.";
public const string AsyncEndCalledOnWrongChannel = @"Async End called on wrong channel.";
public const string AsyncEndCalledWithAnIAsyncResult = @"Async End called with an IAsyncResult from a different Begin method.";
public const string IsolationLevelMismatch2 = @"The received transaction has an isolation level of '{0}' but the service is configured with a TransactionIsolationLevel of '{1}'. The isolation level for received transactions and the service must be the same.";
public const string MessageHeaderIsNull0 = @"The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.";
public const string MessagePropertiesArraySize0 = @"The array passed does not have enough space to hold all the properties contained by this collection.";
public const string DuplicateBehavior1 = @"The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.";
public const string CantCreateChannelWithManualAddressing = @"Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.";
public const string XsdMissingRequiredAttribute1 = @"Missing required '{0}' attribute.";
public const string IgnoreSoapHeaderBinding3 = @"Ignoring invalid SOAP header extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}";
public const string IgnoreSoapFaultBinding3 = @"Ignoring invalid SOAP fault extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}";
public const string IgnoreMessagePart3 = @"Ignoring invalid part in wsdl:message name='{0}' from targetNamespace='{1}'. Reason: {2}";
public const string CannotImportPrivacyNoticeElementWithoutVersionAttribute = @"PrivacyNotice element must have a Version attribute.";
public const string PrivacyNoticeElementVersionAttributeInvalid = @"PrivacyNotice element Version attribute must have an integer value.";





public const string MsmqActiveDirectoryRequiresNativeTransfer = @"Binding validation failed. The client cannot send messages. A conflict in the binding properties caused this failure. The UseActiveDirectory is set to true and QueueTransferProtocol is set to Native. To resolve the conflict, correct one of the properties.";
public const string MsmqAdvancedPoisonHandlingRequired = @"Binding validation failed because the binding's ReceiveErrorHandlig property is set to Move or Reject while the version of MSMQ installed on this system is not 4.0 or higher. The channel listener cannot be opened. Resolve the conflict by setting the ReceiveErrorHandling property to Drop or Fault, or by upgrading to MSMQ v4.0.";
public const string MsmqAuthCertificateRequiresProtectionSign = @"Binding validation failed because the binding's MsmqAuthenticationMode property is set to Certificate while the MsmqProtectionLevel property is not set to Sign or EncryptAndSign. The channel factory or service host cannot be opened. Resolve the conflict by correcting one of the properties.";
public const string MsmqAuthNoneRequiresProtectionNone = @"Binding validation failed. The service or the client cannot be started. A conflict in the binding properties caused this failure. The MsmqAuthenticationMode is set to None and MsmqProtectionLevel is not set to None. To resolve to conflict, correct one of the properties.";
public const string MsmqAuthWindowsRequiresProtectionNotNone = @"Binding validation failed because the binding's MsmqAuthenticationMode property is set to WindowsDomain while the MsmqProtectionLevel property is not set to Sign or EncryptAndSign. The channel factory or service host cannot be opened. Resolve the conflict by correcting one of the properties.";
public const string MsmqBadCertificate = @"Creation of a message security context failed because the attached sender certificate was invalid or cannot be validated. The message cannot be received. Ensure that a valid certificate is attached to the message and that the certificate is present in the receiver's certificate store.";
public const string MsmqBadContentType = @"The content type of an incoming message is unknown or not supported. The message cannot be received. Ensure that the sender was configured to use the same message encoder as the receiver.";
public const string MsmqBadFrame = @"An incoming MSMQ message contained invalid or unexpected .NET Message Framing information in its body. The message cannot be received. Ensure that the sender is using a compatible service contract with a matching SessionMode.";
public const string MsmqBadXml = @"An XML error was encountered while reading a WCF message. The message cannot be received. Ensure the message was sent by a WCF client which used an identical message encoder.";
public const string MsmqBatchRequiresTransactionScope = @"TransactedBatchingBehavior validation failed because none of the service operations had the TransactionScopeRequired property set to true on their OperationBehavior attribute. The service host cannot be started. Ensure this requirement is met if you wish to use this behavior.";
public const string MsmqByteArrayBodyExpected = @"A mismatch was detected between the serialization format specified in the MsmqIntegrationMessageProperty and the body of the MSMQ message. The message cannot be sent. The serialization format ByteArray requires the body of the MSMQ message to be of type byte[].";
public const string MsmqCannotDeserializeActiveXMessage = @"An error occurred while deserializing an MSMQ message's ActiveX body. The message cannot be received. The specified variant type for the body does not match the actual MSMQ message body.";
public const string MsmqCannotDeserializeXmlMessage = @"An error occurred while deserializing an MSMQ message's XML body. The message cannot be received. Ensure that the service contract is decorated with appropriate [ServiceKnownType] attributes or the TargetSerializationTypes property is set on the MsmqIntegrationBindingElement.";
public const string MsmqCannotUseBodyTypeWithActiveXSerialization = @"The properties of the message are mismatched. The message cannot be sent. The BodyType message property cannot be specified if the ActiveX serialization format is used.";
public const string MsmqCertificateNotFound = @"The sender's X.509 certificate was not found. The message cannot be sent. Ensure the certificate is available in the sender's certificate store.";
public const string MsmqCustomRequiresPerAppDLQ = @"Binding validation failed. The client cannot send the message. The DeadLetterQueue is set to Custom, but the CustomDeadLetterQueue is not specified. Specify the URI of the dead letter queue for each application in the CustomDeadLetterQueue property.";
public const string MsmqDeserializationError = @"An error was encountered while deserializing the message. The message cannot be received.";
public const string MsmqDirectFormatNameRequiredForPoison = @"Binding validation failed because the endpoint listen URI does not represent an MSMQ direct format name. The service host cannot be opened. Make sure you use a direct format name for the endpoint's listen URI.";
public const string MsmqDLQNotLocal = @"The host in the CustomDeadLetterQueue URI is not ""localhost"" or the local machine name. A custom DLQ must reside on the sender's machine.";
public const string MsmqDLQNotWriteable = @"Binding validation failed. The client cannot send a message. The specified dead letter queue does not exist or cannot be written. Ensure the queue exists with the proper authorization to write to it.";
public const string MsmqEncryptRequiresUseAD = @"Binding validation failed because the binding's MsmqProtectionLevel property is set to EncryptAndSign while the UseActiveDirectory is not set to true. The channel factory or the service host cannot be opened. Resolve the conflict by correcting one of the properties.";
public const string MsmqGetPrivateComputerInformationError = @"The version check failed with the error: '{0}'. The version of MSMQ cannot be detected All operations that are on the queued channel will fail. Ensure that MSMQ is installed and is available.";
public const string MsmqInvalidMessageId = @"The message ID '{0}' is not in the right format.";
public const string MsmqInvalidScheme = @"The specified addressing scheme is invalid for this binding. The NetMsmqBinding scheme must be net.msmq. The MsmqIntegrationBinding scheme must be msmq.formatname.";
public const string MsmqInvalidServiceOperationForMsmqIntegrationBinding = @"The MsmqIntegrationBinding validation failed. The service cannot be started. The {0} binding does not support the method signature for the service operation {1} in the {2} contract. Correct the service operation to use the MsmqIntegrationBinding.";
public const string MsmqInvalidTypeDeserialization = @"The ActiveX serialization failed because the serialization format cannot be recognized. The message cannot be received.";
public const string MsmqInvalidTypeSerialization = @"The variant type is not recognized. The ActiveX serialization failed. The message cannot be sent. The specified variant type is not supported.";
public const string MsmqKnownWin32Error = @"{0} ({1}, 0x{2})";
public const string MsmqMessageDoesntHaveIntegrationProperty = @"The message cannot be sent because it's missing an MsmqIntegrationMessageProperty. All messages sent over MSMQ integration channels must carry the MsmqIntegrationMessageProperty.";
public const string MsmqNoAssurancesForVolatile = @"Binding validation failed. The service or the client cannot be started. The ExactlyOnce property is set to true and the Durable property is set to false. This is not supported. To resolve the conflict, correct one of these properties.";
public const string MsmqNonNegativeArgumentExpected = @"Argument must be a positive number or zero.";
public const string MsmqNonTransactionalQueueNeeded = @"A mismatch between the binding and MSMQ queue configuration was detected. The service cannot be started. The ExactlyOnce property is set to false and the queue to read messages from is a transactional queue, Correct the error by setting the ExactlyOnce property to true or create a non-transactional binding.";
public const string MsmqNoMoveForSubqueues = @"Binding validation failed because the URI represents a subqueue and the ReceiveErrorHandling parameter is set to Move. The service host or channel listener cannot be opened. Resolve this conflict by setting the ReceiveErrorHandling to Fault, Drop or Reject.";
public const string MsmqNoSid = @"Creation of a message security context failed because the sender's SID was not found in the message. The message cannot be received. The WindowsDomain MsmqAuthenticationMode requires the sender's SID.";
public const string MsmqOpenError = @"An error occurred while opening the queue:{0}. The  message cannot be sent or received from the queue. Ensure that MSMQ is installed and running. Also ensure that the queue is available to open with the required access mode and authorization.";
public const string MsmqPathLookupError = @"An error occurred when converting the '{0}' queue path name to the format name: {1}. All operations on the queued channel failed. Ensure that the queue address is valid. MSMQ must be installed with Active Directory integration enabled and access to it is available.";
public const string MsmqPerAppDLQRequiresCustom = @"Binding validation failed. The client cannot send messages. The CustomDeadLetterQueue property is set, but the DeadLetterQueue property is not set to Custom. Set the DeadLetterQueue property to Custom.";
public const string MsmqPerAppDLQRequiresExactlyOnce = @"Binding validation failed. The client cannot send messages. A conflict in the binding properties is causing the failure. To use the custom dead letter queue, ExactlyOnce must be set to true to resolve to conflict.";
public const string MsmqPerAppDLQRequiresMsmq4 = @"A mismatch between the binding and MSMQ configuration was detected. The client cannot send messages. To use the custom dead letter queue, you must have MSMQ version 4.0 or higher. If you do not have MSMQ version 4.0 or higher set the DeadLetterQueue property to System or None.";
public const string MsmqPoisonMessage = @"The transport channel detected a poison message. This occurred because the message exceeded the maximum number of delivery attempts or because the channel detected a fundamental problem with the message. The inner exception may contain additional information.";
public const string MsmqQueueNotReadable = @"There was an error opening the queue. Ensure that MSMQ is installed and running, the queue exists and has proper authorization to be read from. The inner exception may contain additional information.";
public const string MsmqReceiveError = @"An error occurred while receiving a message from the queue: {0}. Ensure that MSMQ is installed and running. Make sure the queue is available to receive from.";
public const string MsmqSameTransactionExpected = @"A transaction error occurred for this session. The session channel is faulted. Messages in the session cannot be sent or received. A queued session cannot be associated with more than one transaction. Ensure that all messages in the session are sent or received using a single transaction.";
public const string MsmqSendError = @"An error occurred while sending to the queue: {0}.Ensure that MSMQ is installed and running. If you are sending to a local queue, ensure the queue exists with the required access mode and authorization.";
public const string MsmqSerializationTableFull = @"A serialization error occurred. The message cannot be sent or received. The MSMQ integration channel is able to serialize no more than {0} types.";
public const string MsmqSessionChannelsMustBeClosed = @"Session channels must be closed before the transaction is committed. The channel has faulted and the transaction was rolled back.";
public const string MsmqSessionGramSizeMustBeInIntegerRange = @"The total size of messages sent in this session exceeded the maximum value of Int32. The messages in this session cannot be sent.";
public const string MsmqSessionMessagesNotConsumed = @"An attempt made to close the session channel while there are still messages pending in the session. Current transaction will be rolled back and the session channel will be faulted. Messages in a session must be consumed all at once.";
public const string MsmqStreamBodyExpected = @"A serialization error occurred because of a mismatch between the value of the SerializationFormat property and the type of the body. The message cannot be sent. Ensure the type of the body is Stream or use a different SerializationFormat.";
public const string MsmqTimeSpanTooLarge = @"The message time to live (TTL) is too large. The message cannot be sent. The message TTL cannot exceed the Int32 maximum value.";
public const string MsmqTokenProviderNeededForCertificates = @"A client X.509 certificate was not specified through the channel factory's Credentials property, but one is required when the binding's MsmqAuthenticationMode property is set to Certificate. The message cannot be sent.";
public const string MsmqTransactionNotActive = @"The current transaction is not active. Messages in this session cannot be sent or received and the session channel will be faulted. All messages in a session must be sent or received using a single transaction.";
public const string MsmqTransactionalQueueNeeded = @"Binding validation failed because the binding's ExactlyOnce property is set to true while the destination queue is non-transactional. The service host cannot be opened. Resolve this conflict by setting the ExactlyOnce property to false or creating a transactional queue for this binding.";
public const string MsmqTransactionCurrentRequired = @"A transaction was not found in Transaction.Current but one is required for this operation. The channel cannot be opened. Ensure this operation is being called within a transaction scope.";
public const string MsmqTransactionRequired = @"A transaction is required but is not available. Messages cannot be sent or received. Ensure that the transaction scope is specified to send or receive messages.";
public const string MsmqTransactedDLQExpected = @"A mismatch occurred between the binding and the MSMQ configuration. Messages cannot be sent. The custom dead letter queue specified in the binding must be a transactional queue. Ensure that the  custom dead letter queue address is correct and the queue is a transactional queue.";
public const string MsmqUnexpectedPort = @"The net.msmq scheme does not support port numbers. To correct this, remove the port number from the URI.";
public const string MsmqUnknownWin32Error = @"Unrecognized error {0} (0x{1})";
public const string MsmqUnsupportedSerializationFormat = @"The serialization failed because the serialization format '{0}' is not supported. The message cannot be sent or received.";
public const string MsmqWindowsAuthnRequiresAD = @"Binding validation failed because the binding's MsmqAuthenticationMode property is set to WindowsDomain but MSMQ is installed with Active Directory integration disabled. The channel factory or service host cannot be opened.";
public const string MsmqWrongPrivateQueueSyntax = @"The URL in invalid. The URL for the queue cannot contain the '$' character. Use the syntax in net.msmq://machine/private/queueName to address a private queue.";
public const string MsmqWrongUri = @"The URI is invalid because it is missing a host.";




public const string XDCannotFindValueInDictionaryString = @"Cannot find '{0}' value in dictionary string.";
 


public const string WmiGetObject = @"WMI GetObject Query: {0}";
public const string WmiPutInstance = @"WMI PutInstance Class: {0}";



public const string ObjectMustBeOpenedToDequeue = @"Cannot dequeue a '{0}' object while in the Created state.";
public const string NoChannelBuilderAvailable = @"The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.";
public const string InvalidBindingScheme = @"The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.";
public const string CustomBindingRequiresTransport = @"Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.";
public const string TransportBindingElementMustBeLast = @"In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.";
public const string MessageVersionMissingFromBinding = @"None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty<MessageVersion> method.";
public const string NotAllBindingElementsBuilt = @"Some of the binding elements in this binding were not used when building the ChannelFactory.  This may be have been caused by the binding elements being in an invalid order (for example, the TransportBindingElement must be last). The following binding elements were not built: {0}.";
public const string MultipleMebesInParameters = @"More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.";
public const string MultipleStreamUpgradeProvidersInParameters = @"More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.";
public const string MultiplePeerResolverBindingElementsinParameters = @"More than one PeerResolverBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple PeerResolverBindingElements in a CustomBinding. Remove all but one of these elements.";
public const string MultiplePeerCustomResolverBindingElementsInParameters = @"More than one PeerCustomResolverBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple PeerCustomResolverBindingElement in a CustomBinding. Remove all but one of these elements.";
public const string SecurityCapabilitiesMismatched = @"The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.";
public const string BaseAddressMustBeAbsolute = @"Only an absolute Uri can be used as a base address.";
public const string BaseAddressDuplicateScheme = @"This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection.";
public const string BaseAddressCannotHaveUserInfo = @"A base address cannot contain a Uri user info section.";
public const string TransportBindingElementNotFound = @"The binding does not contain a TransportBindingElement.";
public const string ChannelDemuxerBindingElementNotFound = @"The binding does not contain a ChannelDemuxerBindingElement.";
public const string BaseAddressCannotHaveQuery = @"A base address cannot contain a Uri query string.";
public const string BaseAddressCannotHaveFragment = @"A base address cannot contain a Uri fragment.";
public const string UriMustBeAbsolute = @"The given URI must be absolute.";





public const string ConfigBindingCannotBeConfigured = @"The binding on the service endpoint cannot be configured.";
public const string ConfigBindingExtensionNotFound = @"Configuration binding extension '{0}' could not be found. Verify that this binding extension is properly registered in system.serviceModel/extensions/bindingExtensions and that it is spelled correctly.";
public const string ConfigBindingReferenceCycleDetected = @"A binding reference cycle was detected in your configuration. The following reference cycle must be removed: {0}.";
public const string ConfigBindingTypeCannotBeNullOrEmpty = @"The binding specified in configuration cannot be null or an empty string.  Please specify a valid binding.";
public const string ConfigCannotParseXPathFilter = @"Cannot parse type '{0}' into a System.ServiceModel.Dispatcher.XPathMessageFilter.";
public const string ConfigXPathFilterMustNotBeEmpty = @"Filter element body must not be empty.";
public const string ConfigDuplicateItem = @"An extension named {0} already appears in the {1}. Extension names must be unique.";
public const string ConfigDuplicateExtensionName = @" An extension of name '{0}' already appears in extension collection. Extension names must be unique.";
public const string ConfigDuplicateExtensionType = @"An extension of type '{0}' already appears in extension collection. Extension types must be unique.";
public const string ConfigDuplicateKey = @"A child element with the element name '{0}' already exists.  Child elements can only be added once.";
public const string ConfigDuplicateKeyAtSameScope = @"A child element named '{0}' with same key already exists at the same configuration scope. Collection elements must be unique within the same configuration scope (e.g. the same application.config file). Duplicate key value:  '{1}'.";
public const string ConfigElementKeyNull = @"The '{0}' configuration element key cannot be null.";
public const string ConfigElementKeysNull = @"At least one of the configuration element keys '{0}' must not be null.";
public const string ConfigElementTypeNotAllowed = @"Extension element '{0}' cannot be added to this element.  Verify that the extension is registered in the extension collection at system.serviceModel/extensions/{1}.";
public const string ConfigExtensionCollectionNotFound = @"Extension collection '{0}' not found.";
public const string ConfigExtensionTypeNotRegisteredInCollection = @"The extension of type '{0}' is not registered in the extension collection '{1}'.";
public const string ConfigInvalidAuthorizationPolicyType = @"Invalid value in policyType. The policyType '{0}' does not implement from '{1}'.";
public const string ConfigInvalidBindingConfigurationName = @"The {1} binding does not have a configured binding named '{0}'.";
public const string ConfigInvalidBindingName = @"The binding at {1} does not have a configured binding named '{0}'. This is an invalid value for {2}.";
public const string ConfigInvalidCommonEndpointBehaviorType = @"Cannot add the behavior extension '{0}' to the common endpoint behavior because it does not implement '{1}'.";
public const string ConfigInvalidCommonServiceBehaviorType = @"Cannot add the behavior extension '{0}' to the common service behavior because it does not implement '{1}'.";
public const string ConfigInvalidCertificateValidatorType = @"Invalid value for the certificate validator type. The type '{0}' does not derive from the appropriate base class '{1}'.";
public const string ConfigInvalidClientCredentialsType = @"Invalid value for the client credentials type. The type '{0}' does not derive from the appropriate base class '{1}'.";
public const string ConfigInvalidClassFactoryValue = @"The value '{0}' is not a valid instance of type '{1}'.";
public const string ConfigInvalidClassInstanceValue = @"The instance is not a valid configurable value of type '{0}'.";
public const string ConfigInvalidEncodingValue = @"{0} is not a valid encoding string for System.Text.Encoding.GetEncoding(string).";
public const string ConfigInvalidEndpointBehavior = @"There is no endpoint behavior named '{0}'.";
public const string ConfigInvalidEndpointBehaviorType = @"Cannot add the '{0}' behavior extension to '{1}' endpoint behavior because the underlying behavior type does not implement the IEndpointBehavior interface.";
public const string ConfigInvalidExtensionElement = @"Invalid element in configuration. The extension '{0}' does not derive from correct extension base type '{1}'.";
public const string ConfigInvalidExtensionElementName = @"Invalid element in configuration. The extension name '{0}' is not registered in the collection at system.serviceModel/extensions/{1}.";
public const string ConfigInvalidExtensionType = @"The '{0}' type must derive from {1} to be used in the {2} collection.";
public const string ConfigInvalidKeyType = @"The element {0} requires a key of type '{1}'. Type of the key passed in: '{2}'.";
public const string ConfigInvalidReliableMessagingVersionValue = @"'{0}' is not a valid reliable messaging version.  Valid values are 'WSReliableMessagingFebruary2005' and 'WSReliableMessaging11'.";
public const string ConfigInvalidSamlSerializerType = @"Invalid value for the saml serializer type. The type '{0}' does not derive from the appropriate base class: '{1}'.";
public const string ConfigInvalidSection = @"Invalid binding path.  There is no binding registered with the configuration path '{0}'.";
public const string ConfigInvalidServiceCredentialsType = @"Invalid value for the service credentials type. The type '{0}' does not derive from the appropriate base class '{1}'.";
public const string ConfigInvalidSecurityStateEncoderType = @"Invalid value for the  security state encoder type. The type '{0}' does not derive from the appropriate base class '{1}'.";
public const string ConfigInvalidUserNamePasswordValidatorType = @"Invalid value for the username password validator type. The type '{0}' does not derive from the appropriate base class '{1}'.";
public const string ConfigInvalidServiceAuthorizationManagerType = @"Invalid value for serviceAuthorizationManagerType. The serviceAuthorizationManagerType '{0}' does not derive from '{1}'.";
public const string ConfigInvalidServiceBehavior = @"There is no service behavior named '{0}'.";
public const string ConfigInvalidServiceBehaviorType = @"Cannot add the behavior extension '{0}' to the service behavior named '{1}' because the underlying behavior type does not implement the IServiceBehavior interface.";
public const string ConfigInvalidStartValue = @"Start must be between 0 and {0}. Value passed in is {1}.";
public const string ConfigInvalidTransactionFlowProtocolValue = @"'{0}' is not a valid transaction protocol.  Valid values are 'OleTransactions', 'WSAtomicTransactionOctober2004', and 'WSAtomicTransaction11'.";
public const string ConfigInvalidType = @"The type '{0}' registered for extension '{1}' could not be loaded.";
public const string ConfigInvalidTypeForBinding = @"Invalid binding type for binding extension configuration object.  This binding extension manages configuration of binding type '{0}' and cannot act upon type '{1}'.";
public const string ConfigInvalidTypeForBindingElement = @"Invalid binding element type for binding element extension configuration object.  This binding element extension manages configuration of binding element type '{0}' and cannot act upon type '{1}'.";
public const string ConfigKeyNotFoundInElementCollection = @"No elements matching the key '{0}' were found in the configuration element collection.";
public const string ConfigKeysDoNotMatch = @"The key does not match the indexer key. When setting the value of a specific index, the key of the desired value must match the index at which it is being set. Key on element (expected value): {0}. Key provided to indexer: {1}.";
public const string ConfigMessageEncodingAlreadyInBinding = @"Cannot add the message encoding element '{0}'. Another message encoding element already exists in the binding '{1}'. There can only be one message encoding element for each binding.";
public const string ConfigNoExtensionCollectionAssociatedWithType = @"Cannot find the extension collection associated with extension of type '{0}'.";
public const string ConfigNullIssuerAddress = @"Federated issuer address cannot be null when specifying an issuer binding.";
public const string ConfigReadOnly = @"The configuration is read only.";
public const string ConfigSectionNotFound = @"The '{0}' configuration section cannot be created. The machine.config file is missing information. Verify that this configuration section is properly registered and that you have correctly spelled the section name. For Windows Communication Foundation sections, run ServiceModelReg.exe -i to fix this error.";
public const string ConfigStreamUpgradeElementAlreadyInBinding = @"Cannot add stream upgrade element '{0}'. Another stream upgrade element already exists in the binding '{1}'. There can only be one stream update element per binding.";
public const string ConfigTransportAlreadyInBinding = @"Cannot add the transport element '{0}'. Another transport element already exists in the binding '{1}'. There can only be one transport element for each binding.";
public const string ConfigXmlElementMustBeSet = @"The XmlElement must contain XML content.";
public const string ConfigXPathFilterIsNull = @"The XPathFilter for an XPathFilterElement cannot be null.";
public const string ConfigXPathNamespacePrefixNotFound = @"Namespace prefix '{0}' referenced in XPath expression was not found.";
public const string Default = @"(Default)";





public const string AdminMTAWorkerThreadException = @"MTAWorkerThread exception";




public const string InternalError = @"An unexpected error has occurred.";




public const string ClsidNotInApplication = @"The CLSID specified in the service file is not configured in the specified application. (The CLSID is {0}, the AppID is {1}.)";
public const string ClsidNotInConfiguration = @"The CLSID specified in the service file does not have a service element in a configuration file. (The CLSID is {0}.)";
public const string EndpointNotAnIID = @"An endpoint configured for the COM+ CLSID {0} is not a configured interface on the class. (The contract type is {1}.)";
public const string ServiceStringFormatError = @"The COM+ string in the .svc file was formatted incorrectly. (The string is ""{0}"".)";
public const string ContractTypeNotAnIID = @"The contract type name in the configuration file was not in the form of an interface identifier. (The string is ""{0}"".)";
public const string ApplicationNotFound = @"The configured application was not found. (The Application ID was {0}.)";
public const string NoVoteIssued = @" A transaction vote request was completed, but there was no outstanding vote request.";
public const string FailedToConvertTypelibraryToAssembly = @"Failed to convert type library to assembly";
public const string BadInterfaceVersion = @"Incorrect Interface version in registry";
public const string FailedToLoadTypeLibrary = @"Failed to load type library";
public const string NativeTypeLibraryNotAllowed = @" An attempt to load the native type library '{0}' was made. Native type libraries cannot be loaded.";
public const string InterfaceNotFoundInAssembly = @"Could not find interface in the Assembly";
public const string UdtNotFoundInAssembly = @"The '{0}' user-defined type could not be found. Ensure that the correct type and type library are registered and specified.";
public const string UnknownMonikerKeyword = @"Could not find keyword {0}.";
public const string MonikerIncorectSerializer = @"Invalid serializer specified. The only valid values are 'xml' and 'datacontract'.";
public const string NoEqualSignFound = @"The keyword '{0}' has no equal sign following it. Ensure that each keyword is followed by an equal sign and a value.";
public const string KewordMissingValue = @"No value found for a keyword.";
public const string BadlyTerminatedValue = @"Badly terminated value {0}.";
public const string MissingQuote = @"Missing Quote in value {0}.";
public const string RepeatedKeyword = @"Repeated moniker keyword.";
public const string InterfaceNotFoundInConfig = @"Interface {0} not found in configuration.";
public const string CannotHaveNullOrEmptyNameOrNamespaceForIID = @"Interface {0} has a null namespace or name.";
public const string MethodGivenInConfigNotFoundOnInterface = @"Method {0} given in config was not found on interface {1}.";
public const string MonikerIncorrectServerIdentityForMex = @"Only one type of server identity can be specified.";
public const string MonikerAddressNotSpecified = @"Address not specified.";
public const string MonikerMexBindingSectionNameNotSpecified = @"Mex binding section name attribute not specified.";
public const string MonikerMexAddressNotSpecified = @"Mex address not specified.";
public const string MonikerContractNotSpecified = @"Contract not specified.";
public const string MonikerBindingNotSpecified = @"Binding not specified.";
public const string MonikerBindingNamespacetNotSpecified = @"Binding namespace not specified.";
public const string MonikerFailedToDoMexRetrieve = @"Failed to do mex retrieval:{0}.";
public const string MonikerContractNotFoundInRetreivedMex = @"None of the contract in metadata matched the contract specified.";
public const string MonikerNoneOfTheBindingMatchedTheSpecifiedBinding = @"The contract does not have an endpoint supporting the binding specified.";
public const string MonikerMissingColon = @"Moniker Missing Colon";
public const string MonikerIncorrectServerIdentity = @"Multiple server identity keywords were specified. Ensure that at most one identity keyword is specified.";
public const string NoInterface = @"The object does not support the interface '{0}'.";
public const string DuplicateTokenExFailed = @"Could not duplicate the token (error=0x{0:X}).";
public const string AccessCheckFailed = @"Could not perform an AccessCheck (error=0x{0:X}).";
public const string ImpersonateAnonymousTokenFailed = @"Could not impersonate the anonymous user (error=0x{0:X}).";
public const string OnlyByRefVariantSafeArraysAllowed = @"The provided SafeArray parameter was passed by value. SafeArray parameters must be passed by reference.";
public const string OnlyOneDimensionalSafeArraysAllowed = @" Multi-dimensional SafeArray parameters cannot be used.";
public const string OnlyVariantTypeElementsAllowed = @"The elements of the SafeArray must be of the type VARIANT.";
public const string OnlyZeroLBoundAllowed = @"The lower bound of the SafeArray was not zero. SafeArrays with a lower bound other than zero cannot be used.";
public const string OpenThreadTokenFailed = @"Could not open the thread token (error=0x{0:X}).";
public const string OpenProcessTokenFailed = @"Could not open the process token (error=0x{0:X}).";
public const string InvalidIsolationLevelValue = @"The isolation level for component {0} is invalid. (The value was {1}.)";
public const string UnsupportedConversion = @"The conversion between the client parameter type '{0}' to the required server parameter type '{1}' cannot be performed.";
public const string FailedProxyProviderCreation = @"The required outer proxy could not be created. Ensure that the service moniker is correctly installed and registered.";
public const string UnableToLoadDll = @"Cannot load library {0}. Ensure that WCF is properly installed.";
public const string InterfaceNotRegistered = @"Interface Not Registered";
public const string BadInterfaceRegistration = @"Bad Interface Registration";
public const string NotAComObject = @"The argument passed to SetObject is not a COM object.";
public const string NoTypeLibraryFoundForInterface = @"No type library available for interface";
public const string CannotFindClsidInApplication = @"Cannot find CLSID {0} in COM+ application {1}.";
public const string ComActivationAccessDenied = @"Cannot create an instance of the specified service: access is denied.";
public const string ComActivationFailure = @"An internal error occurred attempting to create an instance of the specified service.";
public const string ComDllHostInitializerFoundNoServices = @"No services are configured for the application.";
public const string ComRequiresWindowsSecurity = @"Access is denied. The message was not authenticated with a valid windows identity.";
public const string ComInconsistentSessionRequirements = @"The session requirements of the contracts are inconsistent. All COM contracts in a service must have the same session requirement.";
public const string ComMessageAccessDenied = @"Access is denied.";
public const string VariantArrayNull = @"Parameter at index {0} is null.";
public const string UnableToRetrievepUnk = @"Unable to retrieve IUnknown for object.";
public const string PersistWrapperIsNull = @"QueryInterface succeeded but the persistable type wrapper was null.";
public const string UnexpectedThreadingModel = @"Unexpected threading model. WCF/COM+ integration only supports STA and MTA threading models.";
public const string NoneOfTheMethodsForInterfaceFoundInConfig = @"None of the methods were found for interface {0}.";
public const string ComOperationNotFound = @"The {0} operation on the service {1} could not be found in the catalog.";
public const string InvalidWebServiceInterface = @"The interface with IID {0} cannot be exposed as a web service";
public const string InvalidWebServiceParameter = @"The parameter named {0} of type {1} on method {2} of interface {3} cannot be serialized.";
public const string InvalidWebServiceReturnValue = @"The return value of type {0} on method {1} of interface {2} cannot be serialized.";
public const string OnlyClsidsAllowedForServiceType = @"The COM+ Integration service '{0}' specified in configuration is not in a supported format and could not be started. Ensure that the configuration is correctly specified.";
public const string OperationNotFound = @"The method '{0}' could not be found. Ensure that the correct method name is specified.";
public const string BadDispID = @"The Dispatch ID '{0}' could not be found or is invalid.";
public const string ComNoAsyncOperationsAllowed = @"At least one operation is asynchronous. Asynchronous operations are not allowed.";
public const string ComDuplicateOperation = @"There are duplicate operations, which is invalid. Remove the duplicates.";
public const string BadParamCount = @"The number of parameters in the request did not match the number supported by the method. Ensure that the correct number of parameters are specified.";
public const string BindingNotFoundInConfig = @"Binding type {0} instance {1} not found in config.";
public const string AddressNotSpecified = @"The required address keyword was not specified.";
public const string BindingNotSpecified = @"The required binding keyword was not specified or is not valid.";
public const string OnlyVariantAllowedByRef = @"A VARIANT parameter was passed by value. VARIANT parameters must be passed by reference.";
public const string CannotResolveTypeForParamInMessageDescription = @"The type for the '{0}' parameter in '{1}' within the namespace '{2}' cannot not be resolved.";
public const string TooLate = @"The operation cannot be performed after the communications channel has been created.";
public const string RequireConfiguredMethods = @"The interface with IID {0} has no methods configured in the COM+ catalog and cannot be exposed as a web service.";
public const string RequireConfiguredInterfaces = @"The interface with IID {0} is not configured in the COM+ catalog and cannot be exposed as a web service.";
public const string CannotCreateChannelOption = @"The channeloption intrinsic object cannot be created because the channel builder is not initialized.";
public const string NoTransactionInContext = @"There is no transaction in the context of the operation.";
public const string IssuedTokenFlowNotAllowed = @"The service does not accept issued tokens.";
public const string GeneralSchemaValidationError = @"There was an error verifying some XML Schemas generated during export:\r\n{0}";
public const string SchemaValidationError = @"There was a validation error on a schema generated during export:\r\n    Source: {0}\r\n    Line: {1} Column: {2}\r\n   Validation Error: {3}";
public const string ContractBindingAddressCannotBeNull = @"The Address, Binding and Contract keywords are required.";
public const string TypeLoadForContractTypeIIDFailedWith = @"Type load for contract interface ID {0} failed with Error:{1}.";
public const string BindingLoadFromConfigFailedWith = @"Fail to load binding {0} from config. Error:{1}.";
public const string PooledApplicationNotSupportedForComplusHostedScenarios = @"Application {0} is marked Pooled. Pooled applications are not supported under COM+ hosting.";
public const string RecycledApplicationNotSupportedForComplusHostedScenarios = @"Application {0} has recycling enabled. Recycling of applications is not supported under COM+ hosting.";
public const string BadImpersonationLevelForOutOfProcWas = @"The client token at least needs to have the SecurityImpersonationLevel of at least Impersonation for Out of process Webhost activations.";
public const string ComPlusInstanceProviderRequiresMessage0 = @"This InstanceContext requires a valid Message to obtain the instance.";
public const string ComPlusInstanceCreationRequestSchema = @"From: {0}\nAppId: {1}\nClsId: {2}\nIncoming TransactionId: {3}\nRequesting Identity: {4}";
public const string ComPlusMethodCallSchema = @"From: {0}\nAppId: {1}\nClsId: {2}\nIid: {3}\nAction: {4}\nInstance Id: {5}\nManaged Thread Id: {6}\nUnmanaged Thread Id: {7}\nRequesting Identity: {8}";
public const string ComPlusServiceSchema = @"AppId: {0}\nClsId: {1}\n";
public const string ComPlusServiceSchemaDllHost = @"AppId: {0}";
public const string ComPlusTLBImportSchema = @"Iid: {0}\nType Library ID: {1}";
public const string ComPlusServiceHostStartingServiceErrorNoQFE = @"A Windows hotfix or later service pack is required on Windows XP and Windows Server 2003 to use WS-AtomicTransaction and COM+ Integration Web service transaction functionality. See the Microsoft .NET Framework 3.0 release notes for instructions on installing the required hotfix.";
public const string ComIntegrationManifestCreationFailed = @"Generating manifest file {0} failed with {1}.";
public const string TempDirectoryNotFound = @"Directory {0} not found.";
public const string CannotAccessDirectory = @"Cannot access directory {0}.";
public const string CLSIDDoesNotSupportIPersistStream = @"The object with CLSID '{0}' does not support the required IPersistStream interface.";
public const string CLSIDOfTypeDoesNotMatch = @"CLSID of type {0} does not match the CLSID on PersistStreamTypeWrapper which is {1}.";
public const string TargetObjectDoesNotSupportIPersistStream = @"Target object does not support IPersistStream.";
public const string TargetTypeIsAnIntefaceButCorrespoindingTypeIsNotPersistStreamTypeWrapper = @"Target type is an interface but corresponding type is not PersistStreamTypeWrapper.";
public const string NotAllowedPersistableCLSID = @"CLSID {0} is not allowed.";
public const string TransferringToComplus = @"Transferring to ComPlus logical thread {0}.";
public const string NamedArgsNotSupported = @"The cNamedArgs parameter is not supported and must be 0.";
public const string MexBindingNotFoundInConfig = @"Binding '{0}' was not found in config. The config file must be present and contain a binding matching the one specified in the moniker.";





public const string ClaimTypeCannotBeEmpty = @"The claimType cannot be an empty string.";
public const string X509ChainIsEmpty = @"X509Chain does not have any valid certificates.";
public const string MissingCustomCertificateValidator = @"X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.";
public const string MissingMembershipProvider = @"UserNamePasswordValidationMode.MembershipProvider requires a MembershipProvider. Specify the MembershipProvider property.";
public const string MissingCustomUserNamePasswordValidator = @"UserNamePasswordValidationMode.Custom requires a CustomUserNamePasswordValidator. Specify the CustomUserNamePasswordValidator property.";
public const string SpnegoImpersonationLevelCannotBeSetToNone = @"The Security Support Provider Interface does not support Impersonation level 'None'. Specify Identification, Impersonation or Delegation level.";
public const string PublicKeyNotRSA = @"The public key is not an RSA key.";
public const string SecurityAuditFailToLoadDll = @"The '{0}' dynamic link library (dll) failed to load.";
public const string SecurityAuditPlatformNotSupported = @"Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.";
public const string NoPrincipalSpecifiedInAuthorizationContext = @"No custom principal is specified in the authorization context.";
public const string AccessDenied = @"Access is denied.";
public const string SecurityAuditNotSupportedOnChannelFactory = @"SecurityAuditBehavior is not supported on the channel factory.";






public const string ExpiredTokenInChannelParameters = @"The Infocard token created during channel intialization has expired. Please create a new channel to reacquire token.";
public const string NoTokenInChannelParameters = @"No Infocard token was found in the ChannelParameters. Infocard requires that the security token be created during channel intialization.";





public const string CannotReadKeyIdentifier = @"Cannot read the KeyIdentifier from the '{0}' element with the '{1}' namespace .";
public const string CannotReadKeyIdentifierClause = @"Cannot read KeyIdentifierClause from element '{0}' with namespace '{1}'.  Custom KeyIdentifierClauses require custom SecurityTokenSerializers, please refer to the SDK for examples.";
public const string UnknownEncodingInKeyIdentifier = @"Unrecognized encoding while reading key identifier.";




public const string PeerMessageMustHaveVia = @"Message with action {0} received from a neighbor is missing a via Header.";
public const string PeerLinkUtilityInvalidValues = @"The LinkUtility message received from a neighbor has invalid values for usefull '{0}' and total '{1}'.";
public const string PeerNeighborInvalidState = @"Internal Error: Peer Neighbor state change from {0} to {1} is invalid.";
public const string PeerMaxReceivedMessageSizeConflict = @"The MaxReceivedMessageSize of the associated listener ({0}) is greater than the MaxReceivedMessageSize of the PeerNode ({1}) with the meshid ({2}), ensure that all ChannelFactories and Endpoints for this mesh have the same configuration for MaxRecievedMessageSize.";
public const string PeerConflictingPeerNodeSettings = @"Binding settings conflict with an existing instance that is using the same mesh name. Check the value of the property {0}.";
public const string ArgumentOutOfRange = @"value must be >= {0} and <= {1}.";
public const string PeerChannelViaTooLong = @"Invalid message: the peer channel via ({0}) has a size of ({1}) it exceeds the maximum via size of ({2}).";
public const string PeerNodeAborted = @"The PeerNode cannot be opened because it has been Aborted.";
public const string PeerPnrpNotAvailable = @"PNRP is not available. Please refer to the documentation with your system for details on how to install and enable PNRP.";
public const string PeerPnrpNotInstalled = @"The PNRP service is not installed on this machine. Please refer to the documentation with your system for details on how to install and enable PNRP.";
public const string PeerResolverBindingElementRequired = @"A PeerResolverBindingElement is required in the {0} binding. The default resolver (PNRP) is not available.";
public const string PeerResolverRequired = @"Resolver must be specified. The default resolver (PNRP) is not available. Please refer to the documentation with your system for details on how to install and enable PNRP.";
public const string PeerResolverInvalid = @"The specified ResolverType: {0} cannot be loaded.  Please ensure that the type name specified refers to a type that can be loaded.";
public const string PeerResolverSettingsInvalid = @"Specified resolver settings are not enough to create a valid resolver.  Please ensure that a ResolverType and an Address is specified for the custom resolver.";
public const string PeerListenIPAddressInvalid = @"The ListenIPAddress {0} is invalid.";
public const string PeerFlooderDisposed = @"Internal Error. PeerFlooder instance is already disposed. It cannot be used to send messages.";
public const string PeerPnrpIllegalUri = @"Internal Error. Address of the Service cannot be registered with PNRP.";
public const string PeerInvalidRegistrationId = @"The registrationId {0} is invalid.";
public const string PeerConflictingHeader = @"Application message contains a header that conflicts with a PeerChannel specific header. Name = {0} and Namespace = {1}.";
public const string PnrpNoClouds = @"PNRP could not find any clouds that match the current operation.";
public const string PnrpAddressesUnsupported = @"""Specified addresses can not be registered with PNRP because either PNRP is not enabled or the specified addresses do not have corresponding clouds. Please refer to the documentation with your system for details on how to install and enable PNRP.""";
public const string InsufficientCryptoSupport = @"The binding's PeerTransportSecuritySettings can not be supported under the current system security configuration.";
public const string InsufficientCredentials = @"Credentials specified are not sufficient to carry requested operation. Please specify a valid value for {0}.";
public const string UnexpectedSecurityTokensDuringHandshake = @"Connection was not accepted because the SecurityContext contained tokens that do not match the current security settings.";
public const string PnrpAddressesExceedLimit = @"Addresses specified in the registration exceed PNRP's per registration address limit.";
public const string InsufficientResolverSettings = @"Provided information is Insufficient to create a valid connection to the resolver service.";
public const string InvalidResolverMode = @"Specified PeerResolverMode value {0} is invalid. Please specify either PeerResolveMode.Auto, Default, or Pnrp.";
public const string MustOverrideInitialize = @"concrete PeerResolver implementation must override Initialize to accept metadata about resolver service.";
public const string NotValidWhenOpen = @"The operation: {0} is not valid while the object is in open state.";
public const string NotValidWhenClosed = @"The operation: {0} is not valid while the object is in closed state.";
public const string PeerNullRegistrationInfo = @"Registration info can not be null.  Please ensure that the Register operation is invoked with a valid RegistrationInfo object.";
public const string PeerNullResolveInfo = @"Resolve info can not be null.  Please ensure that the Resolve operation is invoked with a valid ResolveInfo object.";
public const string PeerNullRefreshInfo = @"Refresh info can not be null.  Please ensure that the Refresh operation is invoked with a valid RefreshInfo object.";
public const string PeerInvalidMessageBody = @"MessageBody does not contain a valid {0} message.  Please ensure that the message is well formed.";
public const string DuplicatePeerRegistration = @"A peer registration with the service address {0} already exists.";
public const string PeerNodeToStringFormat = @"MeshId: {0}, Node Id: {1}, Online: {2}, Open: {3}, Port: {4}";
public const string MessagePropagationException = @"The MessagePropagationFilter threw an exception. Please refer to InnerException.";
public const string NotificationException = @"An event notification threw an exception. Please refer to InnerException.";
public const string ResolverException = @"The Peer resolver threw an exception.  Please refer to InnerException.";
public const string PnrpCloudNotFound = @"One of the addresses specified doesn't match any PNRP cloud for registration.{0}";
public const string PnrpCloudDisabled = @"Specified cloud {0} could not be used for the specified operation because it is disabled.";
public const string PnrpCloudResolveOnly = @"Specified cloud {0} is configured for Resolve operations only.";
public const string PnrpPortBlocked = @"Requested PNRP operation {0} cloud not be performed because the port is blocked possibly by a firewall.";
public const string PnrpDuplicatePeerName = @"Specified mesh name {0} cannot be used because a name can only be registered once per process.";
public const string RefreshIntervalMustBeGreaterThanZero = @"Invalid RefreshInterval value of {0}; it must be greater than zero";
public const string CleanupIntervalMustBeGreaterThanZero = @"Invalid CleanupInterval value of {0}; it must be greater than zero";
public const string AmbiguousConnectivitySpec = @"Multiple link-local only interfaces detected.  Please specifiy the interface you require by using the ListenIpAddress attribute in the PeerTransportBindingElement";
public const string MustRegisterMoreThanZeroAddresses = @"Registration with zero addresses detected.   Please call Register with more than zero addresses.";
public const string PeerCertGenFailure = @"Certificate generation has failed. Please see the inner exception for more information.";
public const string PeerThrottleWaiting = @"Throttle on the mesh {0} waiting.";
public const string PeerThrottlePruning = @"Attempting to prune the slow neighbor for the mesh {0}.";
public const string PeerMaintainerStarting = @"Maintainer is starting for the mesh {0}.";
public const string PeerMaintainerConnect = @"Maintainer is attempting a connection to Peer {0} for the mesh {1}.";
public const string PeerMaintainerConnectFailure = @"Maintainer encountered exception when attempting a connection to Peer {0} for the mesh {1}. Exception is {2}.";
public const string PeerMaintainerInitialConnect = @"Mantainer's InitialConnect is running for the mesh {0}.";
public const string PeerMaintainerPruneMode = @"Mantainer is attempting to prune connections for the mesh {0}.";
public const string PeerMaintainerConnectMode = @"Mantainer is attempting to establish additional connections for the mesh {0}.";




public const string OleTxHeaderCorrupt = @"The OLE Transactions header was invalid or corrupt.";
public const string WsatHeaderCorrupt = @"The WS-AtomicTransaction header was invalid or corrupt.";
public const string FailedToDeserializeIssuedToken = @"The issued token accompanying the WS-AtomicTransaction coordination context was invalid or corrupt.";
public const string InvalidPropagationToken = @"The OLE Transactions propagation token received in the message could not be used to unmarshal a transaction. It may be invalid or corrupt.";
public const string InvalidWsatExtendedInfo = @"The WS-AtomicTransaction extended information included in the OLE Transactions propagation token was invalid or corrupt.";
public const string TMCommunicationError = @"An error occurred communicating with the distributed transaction manager.";
public const string UnmarshalTransactionFaulted = @"The WS-AtomicTransaction protocol service could not unmarshal the flowed transaction. The following exception occured: {0}";
public const string InvalidRegistrationHeaderTransactionId = @"The transaction identifier element in the registration header is invalid";
public const string InvalidRegistrationHeaderIdentifier = @"The context identifier element in the registration header is invalid.";
public const string InvalidRegistrationHeaderTokenId = @"The token identifier element in the registration header is invalid.";
public const string InvalidCoordinationContextTransactionId = @"The transaction identifier element in the coordination context is invalid.";
public const string WsatRegistryValueReadError = @"The WS-AtomicTransaction transaction formatter could not read the registry value '{0}'.";
public const string WsatProtocolServiceDisabled = @"The MSDTC transaction manager's WS-AtomicTransaction protocol service '{0}' is disabled and cannot unmarshal incoming transactions.";
public const string InboundTransactionsDisabled = @"The MSDTC transaction manager has disabled incoming transactions.";
public const string SourceTransactionsDisabled = @"The incoming transaction cannot be unmarshaled because the source MSDTC transaction manager has either disabled outbound transactions or disabled its WS-AtomicTransaction protocol service.";
public const string WsatUriCreationFailed = @"A registration service address could not be created from MSDTC whereabouts information.";
public const string WhereaboutsReadFailed = @"The MSDTC whereabouts information could not be deserialized.";
public const string WhereaboutsSignatureMissing = @"The standard whereabouts signature was missing from the MSDTC whereabouts information.";
public const string WhereaboutsImplausibleProtocolCount = @"The MSDTC whereabouts information's protocol count was invalid.";
public const string WhereaboutsImplausibleHostNameByteCount = @"The MSDTC whereabouts information's host name byte count was invalid.";
public const string WhereaboutsInvalidHostName = @"The MSDTC whereabouts information's host name was invalid.";
public const string WhereaboutsNoHostName = @"The MSDTC whereabouts information did not contain a host name.";
public const string InvalidWsatProtocolVersion = @"The specified WSAT protocol version is invalid.";




public const string ActivityCallback = @"Executing user callback.";
public const string ActivityClose = @"Close '{0}'.";
public const string ActivityConstructChannelFactory = @"Construct ChannelFactory. Contract type: '{0}'.";
public const string ActivityConstructServiceHost = @"Construct ServiceHost '{0}'.";
public const string ActivityExecuteMethod = @"Execute '{0}.{1}'.";
public const string ActivityExecuteAsyncMethod = @"Execute Async: Begin: '{0}.{1}'; End: '{2}.{3}'.";
public const string ActivityCloseChannelFactory = @"Close ChannelFactory. Contract type: '{0}'.";
public const string ActivityCloseClientBase = @"Close ClientBase. Contract type: '{0}'.";
public const string ActivityCloseServiceHost = @"Close ServiceHost '{0}'.";
public const string ActivityListenAt = @"Listen at '{0}'.";
public const string ActivityOpen = @"Open '{0}'.";
public const string ActivityOpenServiceHost = @"Open ServiceHost '{0}'.";
public const string ActivityOpenChannelFactory = @"Open ChannelFactory. Contract type: '{0}'.";
public const string ActivityOpenClientBase = @"Open ClientBase. Contract type: '{0}'.";
public const string ActivityProcessAction = @"Process action '{0}'.";
public const string ActivityProcessingMessage = @"Processing message {0}.";
public const string ActivityReceiveBytes = @"Receive bytes on connection '{0}'.";
public const string ActivitySecuritySetup = @"Set up Secure Session.";
public const string ActivitySecurityRenew = @"Renew Secure Session.";
public const string ActivitySecurityClose = @"Close Security Session.";
public const string ActivitySharedListenerConnection = @"Shared listener connection: '{0}'.";
public const string ActivitySocketConnection = @"Socket connection: '{0}'.";
public const string ActivityReadOnConnection = @"Reading data from connection on '{0}'.";
public const string ActivityReceiveAtVia = @"Receiving data at via '{0}'.";




public const string TraceCodeBeginExecuteMethod = @"Begin method execution.";
public const string TraceCodeChannelCreated = @"Created: {0}";
public const string TraceCodeChannelDisposed = @"Disposed: {0}";
public const string TraceCodeChannelMessageSent = @"Sent a message over a channel";
public const string TraceCodeChannelPreparedMessage = @"Prepared message for sending over a channel";
public const string TraceCodeComIntegrationChannelCreated = @"ComPlus:channel created.";
public const string TraceCodeComIntegrationDispatchMethod = @"ComPlus:Dispatch method details.";
public const string TraceCodeComIntegrationDllHostInitializerAddingHost = @"ComPlus:DllHost initializer:Adding host.";
public const string TraceCodeComIntegrationDllHostInitializerStarted = @"ComPlus:Started DllHost initializer.";
public const string TraceCodeComIntegrationDllHostInitializerStarting = @"ComPlus:Starting DllHost initializer.";
public const string TraceCodeComIntegrationDllHostInitializerStopped = @"ComPlus:Stopped DllHost initializer.";
public const string TraceCodeComIntegrationDllHostInitializerStopping = @"ComPlus:Stopping DllHost initializer.";
public const string TraceCodeComIntegrationEnteringActivity = @"ComPlus:Entering COM+ activity.";
public const string TraceCodeComIntegrationExecutingCall = @"ComPlus:Executing COM call.";
public const string TraceCodeComIntegrationInstanceCreationRequest = @"ComPlus:Received instance creation request.";
public const string TraceCodeComIntegrationInstanceCreationSuccess = @"ComPlus:Created instance.";
public const string TraceCodeComIntegrationInstanceReleased = @"ComPlus:Released instance.";
public const string TraceCodeComIntegrationInvokedMethod = @"ComPlus:Invoked method.";
public const string TraceCodeComIntegrationInvokingMethod = @"ComPlus:Invoking method.";
public const string TraceCodeComIntegrationInvokingMethodContextTransaction = @"Complus:Invoking method with transaction in COM+ context.";
public const string TraceCodeComIntegrationInvokingMethodNewTransaction = @"Complus:Invoking method with new incoming transaction.";
public const string TraceCodeComIntegrationLeftActivity = @"ComPlus:Left COM+ activity.";
public const string TraceCodeComIntegrationMexChannelBuilderLoaded = @"Complus:Mex channel loader loaded.";
public const string TraceCodeComIntegrationMexMonikerMetadataExchangeComplete = @"Complus:Metadata exchange completed successfully.";
public const string TraceCodeComIntegrationServiceHostCreatedServiceContract = @"ComPlus:Created service contract.";
public const string TraceCodeComIntegrationServiceHostCreatedServiceEndpoint = @"ComPlus:Created service endpoint.";
public const string TraceCodeComIntegrationServiceHostStartedService = @"ComPlus:Started service.";
public const string TraceCodeComIntegrationServiceHostStartedServiceDetails = @"ComPlus:Started service:details.";
public const string TraceCodeComIntegrationServiceHostStartingService = @"ComPlus:Starting service.";
public const string TraceCodeComIntegrationServiceHostStoppedService = @"ComPlus:Stopped service.";
public const string TraceCodeComIntegrationServiceHostStoppingService = @"ComPlus:Stopping service.";
public const string TraceCodeComIntegrationServiceMonikerParsed = @"ComPlus:Service moniker parsed.";
public const string TraceCodeComIntegrationTLBImportConverterEvent = @"ComPlus:Type library converter event.";
public const string TraceCodeComIntegrationTLBImportFinished = @"ComPlus:Finished type library import.";
public const string TraceCodeComIntegrationTLBImportFromAssembly = @"ComPlus:Type library import: using assembly.";
public const string TraceCodeComIntegrationTLBImportFromTypelib = @"ComPlus:Type library import: using type library.";
public const string TraceCodeComIntegrationTLBImportStarting = @"ComPlus:Starting type library import.";
public const string TraceCodeComIntegrationTxProxyTxAbortedByContext = @"ComPlus:Transaction aborted by COM+ context.";
public const string TraceCodeComIntegrationTxProxyTxAbortedByTM = @"ComPlus:Transaction aborted by Transaction Manager.";
public const string TraceCodeComIntegrationTxProxyTxCommitted = @"ComPlus:Transaction committed.";
public const string TraceCodeComIntegrationTypedChannelBuilderLoaded = @"ComPlus:Typed channel builder loaded.";
public const string TraceCodeComIntegrationWsdlChannelBuilderLoaded = @"ComPlus:WSDL channel builder loaded.";
public const string TraceCodeCommunicationObjectAborted = @"Aborted '{0}'.";
public const string TraceCodeCommunicationObjectAbortFailed = @"Failed to abort {0}";
public const string TraceCodeCommunicationObjectCloseFailed = @"Failed to close {0}";
public const string TraceCodeCommunicationObjectClosed = @"Closed {0}";
public const string TraceCodeCommunicationObjectCreated = @"Created {0}";
public const string TraceCodeCommunicationObjectClosing = @"Closing {0}";
public const string TraceCodeCommunicationObjectDisposing = @"Disposing {0}";
public const string TraceCodeCommunicationObjectFaultReason = @"CommunicationObject faulted due to exception.";
public const string TraceCodeCommunicationObjectFaulted = @"Faulted {0}";
public const string TraceCodeCommunicationObjectOpenFailed = @"Failed to open {0}";
public const string TraceCodeCommunicationObjectOpened = @"Opened {0}";
public const string TraceCodeCommunicationObjectOpening = @"Opening {0}";
public const string TraceCodeConfigurationIsReadOnly = @"The configuration is read-only.";
public const string TraceCodeConfiguredExtensionTypeNotFound = @"Extension type is not configured.";
public const string TraceCodeConnectionAbandoned = @"The connection has been abandoned.";
public const string TraceCodeConnectToIPEndpoint = @"Connection information.";
public const string TraceCodeConnectionPoolCloseException = @"An exception occurred while closing the connections in this connection pool.";
public const string TraceCodeConnectionPoolIdleTimeoutReached = @"A connection has exceeded the idle timeout of this connection pool ({0}) and been closed.";
public const string TraceCodeConnectionPoolLeaseTimeoutReached = @"A connection has exceeded the connection lease timeout of this connection pool ({0}) and been closed.";
public const string TraceCodeConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached = @"MaxOutboundConnectionsPerEndpoint quota ({0}) has been reached, so connection was closed and not stored in this connection pool.";
public const string TraceCodeServerMaxPooledConnectionsQuotaReached = @"MaxOutboundConnectionsPerEndpoint quota ({0}) has been reached, so the connection was closed and not reused by the listener.";
public const string TraceCodeDiagnosticsFailedMessageTrace = @"Failed to trace a message";
public const string TraceCodeDidNotUnderstandMessageHeader = @"Did not understand message header.";
public const string TraceCodeDroppedAMessage = @"A response message was received, but there are no outstanding requests waiting for this message. The message is being dropped.";
public const string TraceCodeCannotBeImportedInCurrentFormat = @"The given schema cannot be imported in this format.";
public const string TraceCodeElementTypeDoesntMatchConfiguredType = @"The type of the element does not match the configuration type.";
public const string TraceCodeEndExecuteMethod = @"End method execution.";
public const string TraceCodeEndpointListenerClose = @"Endpoint listener closed.";
public const string TraceCodeEndpointListenerOpen = @"Endpoint listener opened.";
public const string TraceCodeErrorInvokingUserCode = @"Error invoking user code";
public const string TraceCodeEvaluationContextNotFound = @"Configuration evaluation context not found.";
public const string TraceCodeExportSecurityChannelBindingEntry = @"Starting Security ExportChannelBinding";
public const string TraceCodeExportSecurityChannelBindingExit = @"Finished Security ExportChannelBinding";
public const string TraceCodeExtensionCollectionDoesNotExist = @"The extension collection does not exist.";
public const string TraceCodeExtensionCollectionIsEmpty = @"The extension collection is empty.";
public const string TraceCodeExtensionCollectionNameNotFound = @"Extension element not associated with an extension collection.";
public const string TraceCodeExtensionElementAlreadyExistsInCollection = @"The extension element already exists in the collection.";
public const string TraceCodeFailedToAddAnActivityIdHeader = @"Failed to set an activity id header on an outgoing message";
public const string TraceCodeFailedToReadAnActivityIdHeader = @"Failed to read an activity id header on a message";
public const string TraceCodeFilterNotMatchedNodeQuotaExceeded = @"Evaluating message logging filter against the message exceeded the node quota set on the filter.";
public const string TraceCodeGetBehaviorElement = @"Get BehaviorElement.";
public const string TraceCodeGetChannelEndpointElement = @"Get ChannelEndpointElement.";
public const string TraceCodeGetCommonBehaviors = @"Get machine.config common behaviors.";
public const string TraceCodeGetConfigurationSection = @"Get configuration section.";
public const string TraceCodeGetConfiguredBinding = @"Get configured binding.";
public const string TraceCodeGetDefaultConfiguredBinding = @"Get default configured binding.";
public const string TraceCodeGetServiceElement = @"Get ServiceElement.";
public const string TraceCodeHttpAuthFailed = @"Authentication failed for HTTP(S) connection";
public const string TraceCodeHttpActionMismatch = @"The HTTP SOAPAction header and the wsa:Action SOAP header did not match.";
public const string TraceCodeHttpChannelMessageReceiveFailed = @"Failed to lookup a channel to receive an incoming message. Either the endpoint or the SOAP action was not found.";
public const string TraceCodeHttpChannelRequestAborted = @"Failed to send request message over HTTP";
public const string TraceCodeHttpChannelResponseAborted = @"Failed to send response message over HTTP";
public const string TraceCodeHttpChannelUnexpectedResponse = @"Received bad HTTP response";
public const string TraceCodeHttpResponseReceived = @"HTTP response was received";
public const string TraceCodeHttpChannelConcurrentReceiveQuotaReached = @"The HTTP concurrent receive quota was reached.";
public const string TraceCodeHttpsClientCertificateInvalid = @"Client certificate is invalid.";
public const string TraceCodeHttpsClientCertificateNotPresent = @"Client certificate is required. No certificate was found in the request.";
public const string TraceCodeImportSecurityChannelBindingEntry = @"Starting Security ImportChannelBinding";
public const string TraceCodeImportSecurityChannelBindingExit = @"Finished Security ImportChannelBinding";
public const string TraceCodeIncompatibleExistingTransportManager = @"An existing incompatible transport manager was found for the specified URI.";
public const string TraceCodeInitiatingNamedPipeConnection = @"Initiating Named Pipe connection.";
public const string TraceCodeInitiatingTcpConnection = @"Initiating TCP connection.";
public const string TraceCodeIssuanceTokenProviderBeginSecurityNegotiation = @"The IssuanceTokenProvider has started a new security negotiation.";
public const string TraceCodeIssuanceTokenProviderEndSecurityNegotiation = @"The IssuanceTokenProvider has completed the security negotiation.";
public const string TraceCodeIssuanceTokenProviderRedirectApplied = @"The IssuanceTokenProvider applied a redirection header.";
public const string TraceCodeIssuanceTokenProviderRemovedCachedToken = @"The IssuanceTokenProvider removed the expired service token.";
public const string TraceCodeIssuanceTokenProviderServiceTokenCacheFull = @"IssuanceTokenProvider pruned service token cache.";
public const string TraceCodeIssuanceTokenProviderUsingCachedToken = @"The IssuanceTokenProvider used the cached service token.";
public const string TraceCodeListenerCreated = @"Listener created";
public const string TraceCodeListenerDisposed = @"Listener disposed";
public const string TraceCodeMaxPendingConnectionsReached = @"Maximum number of pending connections has been reached.";
public const string TraceCodeMaxAcceptedChannelsReached = @"Maximum number of inbound session channel has been reached.";
public const string TraceCodeMessageClosed = @"A message was closed";
public const string TraceCodeMessageClosedAgain = @"A message was closed again";
public const string TraceCodeMessageCopied = @"A message was copied";
public const string TraceCodeMessageCountLimitExceeded = @"Reached the limit of messages to log. Message logging is stopping.";
public const string TraceCodeMessageNotLoggedQuotaExceeded = @"Message not logged because its size exceeds configured quota";
public const string TraceCodeMessageRead = @"A message was read";
public const string TraceCodeMessageSent = @"Sent a message over a channel.";
public const string TraceCodeMessageReceived = @"Received a message over a channel.";
public const string TraceCodeMessageWritten = @"A message was written";
public const string TraceCodeMessageProcessingPaused = @"Switched threads while processing a message.";
public const string TraceCodeMsmqCannotPeekOnQueue = @"MsmqActivation service cannot peek on the queue.";
public const string TraceCodeMsmqCannotReadQueues = @"MsmqActivation service cannot discover queues.";
public const string TraceCodeMsmqDatagramReceived = @"MSMQ datagram message received.";
public const string TraceCodeMsmqDatagramSent = @"MSMQ datagram message sent.";
public const string TraceCodeMsmqDetected = @"MSMQ detected successfully.";
public const string TraceCodeMsmqEnteredBatch = @"Entered batching mode.";
public const string TraceCodeMsmqExpectedException = @"Expected exception caught.";
public const string TraceCodeMsmqFoundBaseAddress = @"Hosting environment found the base address for the service.";
public const string TraceCodeMsmqLeftBatch = @"Left batching mode.";
public const string TraceCodeMsmqMatchedApplicationFound = @"MsmqActivation service found application matching queue.";
public const string TraceCodeMsmqMessageLockedUnderTheTransaction = @"Cannot move or delete message because it is still locked under the transaction.";
public const string TraceCodeMsmqMessageDropped = @"Message was dropped.";
public const string TraceCodeMsmqMessageRejected = @"Message was rejected.";
public const string TraceCodeMsmqMoveOrDeleteAttemptFailed = @"Cannot move or delete message.";
public const string TraceCodeMsmqPoisonMessageMovedPoison = @"Poison message moved to the poison subqueue.";
public const string TraceCodeMsmqPoisonMessageMovedRetry = @"Poison message moved to the retry subqueue.";
public const string TraceCodeMsmqPoisonMessageRejected = @"Poison message rejected.";
public const string TraceCodeMsmqPoolFull = @"Pool of the native MSMQ messages is full. This may affect performance.";
public const string TraceCodeMsmqPotentiallyPoisonMessageDetected = @"Transaction which received this message was aborted at least once.";
public const string TraceCodeMsmqQueueClosed = @"MSMQ queue closed.";
public const string TraceCodeMsmqQueueOpened = @"MSMQ queue opened.";
public const string TraceCodeMsmqQueueTransactionalStatusUnknown = @"Cannot detect if the queue is transactional.";
public const string TraceCodeMsmqScanStarted = @"MsmqActivation service started scan for queues.";
public const string TraceCodeMsmqSessiongramReceived = @"MSMQ transport session received.";
public const string TraceCodeMsmqSessiongramSent = @"MSMQ transport session sent.";
public const string TraceCodeMsmqStartingApplication = @"MSMQ Activation service started application.";
public const string TraceCodeMsmqStartingService = @"Hosting environment started service.";
public const string TraceCodeMsmqUnexpectedAcknowledgment = @"Unexpected acknowledgment value.";
public const string TraceCodeNamedPipeChannelMessageReceiveFailed = @"Failed to receive a message over a named pipe channel.";
public const string TraceCodeNamedPipeChannelMessageReceived = @"Received a message over a named pipe channel.";
public const string TraceCodeNegotiationAuthenticatorAttached = @"NegotiationTokenAuthenticator was attached.";
public const string TraceCodeNegotiationTokenProviderAttached = @"NegotiationTokenProvider was attached.";
public const string TraceCodeNoExistingTransportManager = @"No existing transport manager was found for the specified URI.";
public const string TraceCodeOpenedListener = @"Transport is listening at base URI.";
public const string TraceCodeOverridingDuplicateConfigurationKey = @"The configuration system has detected a duplicate key in a different configuration scope and is overriding with the more recent value.";
public const string TraceCodePeerChannelMessageReceived = @"A message was received by a peer channel.";
public const string TraceCodePeerChannelMessageSent = @"A message was sent on a peer channel.";
public const string TraceCodePeerFloodedMessageNotMatched = @"A PeerNode received a message that did not match any local channels.";
public const string TraceCodePeerFloodedMessageNotPropagated = @"A PeerNode received a flooded message that was not propagated further.";
public const string TraceCodePeerFloodedMessageReceived = @"A PeerNode received a flooded message.";
public const string TraceCodePeerFlooderReceiveMessageQuotaExceeded = @"Received message could not be forwarded to other neighbors since it exceeded the quota set for the peer node.";
public const string TraceCodePeerNeighborCloseFailed = @"A Peer Neighbor close has failed.";
public const string TraceCodePeerNeighborClosingFailed = @"A Peer Neighbor closing has failed.";
public const string TraceCodePeerNeighborManagerOffline = @"A Peer Neighbor Manager is offline.";
public const string TraceCodePeerNeighborManagerOnline = @"A Peer Neighbor Manager is online.";
public const string TraceCodePeerNeighborMessageReceived = @"A message was received by a Peer Neighbor.";
public const string TraceCodePeerNeighborNotAccepted = @"A Peer Neighbor was not accepted.";
public const string TraceCodePeerNeighborNotFound = @"A Peer Neighbor was not found.";
public const string TraceCodePeerNeighborOpenFailed = @"A Peer Neighbor open has failed.";
public const string TraceCodePeerNeighborStateChangeFailed = @"A Peer Neighbor state change has failed.";
public const string TraceCodePeerNeighborStateChanged = @"A Peer Neighbor state has changed.";
public const string TraceCodePeerNodeAddressChanged = @"A PeerNode address has changed.";
public const string TraceCodePeerNodeAuthenticationFailure = @"A neighbor connection could not be established due to insufficient or wrong credentials.";
public const string TraceCodePeerNodeAuthenticationTimeout = @"A neighbor security handshake as timed out.";
public const string TraceCodePeerNodeClosed = @"A PeerNode was closed.";
public const string TraceCodePeerNodeClosing = @"A PeerNode is closing.";
public const string TraceCodePeerNodeOpenFailed = @"Peer node open failed.";
public const string TraceCodePeerNodeOpened = @"A PeerNode was opened.";
public const string TraceCodePeerNodeOpening = @"A PeerNode is opening.";
public const string TraceCodePeerReceiveMessageAuthenticationFailure = @"Message source could not be authenticated.";
public const string TraceCodePeerServiceOpened = @"PeerService Opened and listening at '{0}'.";
public const string TraceCodePerformanceCounterFailedToLoad = @"A performance counter failed to load. Some performance counters will not be available.";
public const string TraceCodePerformanceCountersFailed = @"Failed to load the performance counter '{0}'. Some performance counters will not be available";
public const string TraceCodePerformanceCountersFailedDuringUpdate = @"There was an error while updating the performance counter '{0}'. This performance counter will be disabled.";
public const string TraceCodePerformanceCountersFailedForService = @"Loading performance counters for the service failed. Performance counters will not be available for this service.";
public const string TraceCodePerformanceCountersFailedOnRelease = @"Unloading the performance counters failed.";
public const string TraceCodePnrpRegisteredAddresses = @"Registered addresses in PNRP.";
public const string TraceCodePnrpResolvedAddresses = @"Resolved addresses in PNRP.";
public const string TraceCodePnrpResolveException = @"Unexpected Exception during PNRP resolve operation.";
public const string TraceCodePnrpUnregisteredAddresses = @"Unregistered addresses in PNRP.";
public const string TraceCodePrematureDatagramEof = @"A null Message (signalling end of channel) was received from a datagram channel, but the channel is still in the Opened state. This indicates a bug in the datagram channel, and the demuxer receive loop has been prematurely stalled.";
public const string TraceCodePeerMaintainerActivity = @"PeerMaintainer Activity.";
public const string TraceCodeReliableChannelOpened = @"A reliable channel has been opened.";
public const string TraceCodeRemoveBehavior = @"Behavior type already exists in the collection";
public const string TraceCodeRequestChannelReplyReceived = @"Received reply over request channel";
public const string TraceCodeSecurityActiveServerSessionRemoved = @"An active security session was removed by the server.";
public const string TraceCodeSecurityAuditWrittenFailure = @"A failure occurred while writing to the security audit log.";
public const string TraceCodeSecurityAuditWrittenSuccess = @"The security audit log is written successfully.";
public const string TraceCodeSecurityBindingIncomingMessageVerified = @"The security protocol verified the incoming message.";
public const string TraceCodeSecurityBindingOutgoingMessageSecured = @"The security protocol secured the outgoing message.";
public const string TraceCodeSecurityBindingSecureOutgoingMessageFailure = @"The security protocol cannot secure the outgoing message.";
public const string TraceCodeSecurityBindingVerifyIncomingMessageFailure = @"The security protocol cannot verify the incoming message.";
public const string TraceCodeSecurityClientSessionKeyRenewed = @"The client security session renewed the session key.";
public const string TraceCodeSecurityClientSessionCloseSent = @"A Close message was sent by the client security session.";
public const string TraceCodeSecurityClientSessionCloseResponseSent = @"Close response message was sent by client security session.";
public const string TraceCodeSecurityClientSessionCloseMessageReceived = @"Close message was received by client security session.TraceCodeSecurityClientSessionKeyRenewed=Client security session renewed session key.";
public const string TraceCodeSecurityClientSessionPreviousKeyDiscarded = @"The client security session discarded the previous session key.";
public const string TraceCodeSecurityContextTokenCacheFull = @"The SecurityContextSecurityToken cache is full.";
public const string TraceCodeSecurityIdentityDeterminationFailure = @"Identity cannot be determined for an EndpointReference.";
public const string TraceCodeSecurityIdentityDeterminationSuccess = @"Identity was determined for an EndpointReference.";
public const string TraceCodeSecurityIdentityHostNameNormalizationFailure = @"The HostName portion of an endpoint address cannot be normalized.";
public const string TraceCodeSecurityIdentityVerificationFailure = @"Identity verification failed.";
public const string TraceCodeSecurityIdentityVerificationSuccess = @"Identity verification succeeded.";
public const string TraceCodeSecurityImpersonationFailure = @"Security impersonation failed at the server.";
public const string TraceCodeSecurityImpersonationSuccess = @"Security Impersonation succeeded at the server.";
public const string TraceCodeSecurityInactiveSessionFaulted = @"An inactive security session was faulted by the server.";
public const string TraceCodeSecurityNegotiationProcessingFailure = @"Service security negotiation processing failure.";
public const string TraceCodeSecurityNewServerSessionKeyIssued = @"A new security session key was issued by the server.";
public const string TraceCodeSecurityPendingServerSessionAdded = @"A pending security session was added to the server.";
public const string TraceCodeSecurityPendingServerSessionClosed = @"The pending security session was closed by the server.";
public const string TraceCodeSecurityPendingServerSessionActivated = @"A pending security session was activated by the server.";
public const string TraceCodeSecurityServerSessionCloseReceived = @"The server security session received a close message from the client.";
public const string TraceCodeSecurityServerSessionCloseResponseReceived = @"Server security session received Close response message from client.";
public const string TraceCodeSecurityServerSessionAbortedFaultSent = @"Server security session sent session aborted fault to client.";
public const string TraceCodeSecurityServerSessionKeyUpdated = @"The security session key was updated by the server.";
public const string TraceCodeSecurityServerSessionRenewalFaultSent = @"The server security session sent a key renewal fault to the client.";
public const string TraceCodeSecuritySessionCloseResponseSent = @"The server security session sent a close response to the client.";
public const string TraceCodeSecuritySessionServerCloseSent = @"Server security session sent Close to client.";
public const string TraceCodeSecuritySessionAbortedFaultReceived = @"Client security session received session aborted fault from server.";
public const string TraceCodeSecuritySessionAbortedFaultSendFailure = @"Failure sending security session aborted fault to client.";
public const string TraceCodeSecuritySessionClosedResponseReceived = @"The client security session received a closed reponse from the server.";
public const string TraceCodeSecuritySessionClosedResponseSendFailure = @"A failure occurred when sending a security session Close response to the client.";
public const string TraceCodeSecuritySessionServerCloseSendFailure = @"Failure sending security session Close to client.";
public const string TraceCodeSecuritySessionKeyRenewalFaultReceived = @"The client security session received a key renewal fault from the server.";
public const string TraceCodeSecuritySessionRedirectApplied = @"The client security session was redirected.";
public const string TraceCodeSecuritySessionRenewFaultSendFailure = @"A failure occurred when sending a renewal fault on the security session key to the client.";
public const string TraceCodeSecuritySessionRequestorOperationFailure = @"The client security session operation failed.";
public const string TraceCodeSecuritySessionRequestorOperationSuccess = @"The security session operation completed successfully at the client.";
public const string TraceCodeSecuritySessionRequestorStartOperation = @"A security session operation was started at the client.";
public const string TraceCodeSecuritySessionResponderOperationFailure = @"The security session operation failed at the server.";
public const string TraceCodeSecuritySpnToSidMappingFailure = @"The ServicePrincipalName could not be mapped to a SecurityIdentifier.";
public const string TraceCodeSecurityTokenAuthenticatorClosed = @"Security Token Authenticator was closed.";
public const string TraceCodeSecurityTokenAuthenticatorOpened = @"Security Token Authenticator was opened.";
public const string TraceCodeSecurityTokenProviderClosed = @"Security Token Provider was closed.";
public const string TraceCodeSecurityTokenProviderOpened = @"Security Token Provider was opened.";
public const string TraceCodeServiceChannelLifetime = @"ServiceChannel information.";
public const string TraceCodeServiceHostBaseAddresses = @"ServiceHost base addresses.";
public const string TraceCodeServiceHostTimeoutOnClose = @"ServiceHost close operation timedout.";
public const string TraceCodeServiceHostFaulted = @"ServiceHost faulted.";
public const string TraceCodeServiceHostErrorOnReleasePerformanceCounter = @"ServiceHost error on calling ReleasePerformanceCounters.";
public const string TraceCodeServiceThrottleLimitReached = @"The system hit the limit set for throttle '{0}'. Limit for this throttle was set to {1}. Throttle value can be changed by modifying attribute '{2}' in serviceThrottle element or by modifying '{0}' property on behavior ServiceThrottlingBehavior.";
public const string TraceCodeManualFlowThrottleLimitReached = @"The system hit the limit set for the '{0}' throttle. Throttle value can be changed by modifying {0} property on {1}.";
public const string TraceCodeProcessMessage2Paused = @"Switched threads while processing a message for Contract '{0}' at Address '{1}'. ConcurrencyMode for service is set to Single/Reentrant and the service is currently processing another message.";
public const string TraceCodeProcessMessage3Paused = @"Switched threads while processing a message for Contract '{0}' at Address '{1}'. Cannot process more than one transaction at a time and the transaction associated with the previous message is not yet complete. Ensure that the caller has committed the transaction.";
public const string TraceCodeProcessMessage4Paused = @"Switched threads while processing a message for Contract '{0}' at Address '{1}'. UseSynchronizationContext property on ServiceBehaviorAttribute is set to true, and SynchronizationContext.Current was non-null when opening ServiceHost.  If your service seems to be not processing messages, consider setting UseSynchronizationContext to false.";
public const string TraceCodeServiceOperationExceptionOnReply = @"Replying to an operation threw a exception.";
public const string TraceCodeServiceOperationMissingReply = @"The Request/Reply operation {0} has no Reply Message.";
public const string TraceCodeServiceOperationMissingReplyContext = @"The Request/Reply operation {0} has no IRequestContext to use for the reply.";
public const string TraceCodeServiceSecurityNegotiationCompleted = @"Service security negotiation completed.";
public const string TraceCodeSecuritySessionDemuxFailure = @"The incoming message is not part of an existing security session.";
public const string TraceCodeServiceHostCreation = @"Create ServiceHost.";
public const string TraceCodePortSharingClosed = @"The TransportManager was successfully closed.";
public const string TraceCodePortSharingDuplicatedPipe = @"A named pipe was successfully duplicated.";
public const string TraceCodePortSharingDuplicatedSocket = @"A socket was successfully duplicated.";
public const string TraceCodePortSharingDupHandleGranted = @"The PROCESS_DUP_HANDLE access right has been granted to the {0} service's account with SID '{1}'.";
public const string TraceCodePortSharingListening = @"The TransportManager is now successfully listening.";
public const string TraceCodeSkipBehavior = @"Behavior type is not of expected type";
public const string TraceCodeFailedAcceptFromPool = @"An attempt to reuse a pooled connection failed. Another attempt will be made with {0} remaining in the overall timeout.";
public const string TraceCodeFailedPipeConnect = @"An attempt to connect to the named pipe endpoint at '{1}' failed. Another attempt will be made with {0} remaining in the overall timeout.";
public const string TraceCodeSystemTimeResolution = @"The operating system's timer resolution was detected as {0} ticks, which is about {1} milliseconds.";
public const string TraceCodeRequestContextAbort = @"RequestContext aborted";
public const string TraceCodePipeConnectionAbort = @"PipeConnection aborted";
public const string TraceCodeSharedManagerServiceEndpointNotExist = @"The shared memory for the endpoint of the service '{0}' does not exist. The service may not be started.";
public const string TraceCodeSocketConnectionAbort = @"SocketConnection aborted";
public const string TraceCodeSocketConnectionAbortClose = @"SocketConnection aborted under Close";
public const string TraceCodeSocketConnectionClose = @"SocketConnection close";
public const string TraceCodeSocketConnectionCreate = @"SocketConnection create";
public const string TraceCodeSpnegoClientNegotiationCompleted = @"SpnegoTokenProvider completed SSPI negotiation.";
public const string TraceCodeSpnegoServiceNegotiationCompleted = @"SpnegoTokenAuthenticator completed SSPI negotiation.";
public const string TraceCodeSslClientCertMissing = @"The remote SSL client failed to provide a required certificate.";
public const string TraceCodeStreamSecurityUpgradeAccepted = @"The stream security upgrade was accepted successfully.";
public const string TraceCodeTcpChannelMessageReceiveFailed = @"Failed to receive a message over TCP channel";
public const string TraceCodeTcpChannelMessageReceived = @"Received a message over TCP channel";
public const string TraceCodeUnderstoodMessageHeader = @"Understood message header.";
public const string TraceCodeUnhandledAction = @"No service available to handle this action";
public const string TraceCodeUnhandledExceptionInUserOperation = @"Unhandled exception in user operation '{0}.{1}'.";
public const string TraceCodeWebHostCompilation = @"Webhost compilation";
public const string TraceCodeWebHostDebugRequest = @"The request is for DEBUG verb.";
public const string TraceCodeWebHostFailedToActivateService = @"Webhost could not activate service";
public const string TraceCodeWebHostFailedToCompile = @"Webhost couldn't compile service";
public const string TraceCodeWebHostProtocolMisconfigured = @"The protocol is misconfigured in WAS, reconfigure it.";
public const string TraceCodeWebHostServiceActivated = @"Webhost service activated";
public const string TraceCodeWebHostServiceCloseFailed = @"Closing or aborting the service failed.";
public const string TraceCodeWmiPut = @"Setting a value via WMI.";
public const string TraceCodeWsmexNonCriticalWsdlExportError = @"A non-critical error or warning occurred during WSDL Export";
public const string TraceCodeWsmexNonCriticalWsdlImportError = @"A non-critical error or warning occurred in the MetadataExchangeClient during WSDL Import This could result in some endpoints not being imported.";
public const string TraceCodeFailedToOpenIncomingChannel = @"An incoming channel was disposed because there was an error while attempting to open it.";
public const string TraceCodeTransportListen = @"Listen at '{0}'.";
public const string TraceCodeWsrmInvalidCreateSequence = @"An invalid create sequence message was received.";
public const string TraceCodeWsrmInvalidMessage = @"An invalid WS-RM message was received.";
public const string TraceCodeWsrmMaxPendingChannelsReached = @"An incoming create sequence request was rejected because the maximum pending channel count was reached.";
public const string TraceCodeWsrmMessageDropped = @"A message in a WS-RM sequence has been dropped because it could not be buffered.";
public const string TraceCodeWsrmReceiveAcknowledgement = @"WS-RM SequenceAcknowledgement received.";
public const string TraceCodeWsrmReceiveLastSequenceMessage = @"WS-RM Last Sequence message received.";
public const string TraceCodeWsrmReceiveSequenceMessage = @"WS-RM Sequence message received.";
public const string TraceCodeWsrmSendAcknowledgement = @"WS-RM SequenceAcknowledgement sent.";
public const string TraceCodeWsrmSendLastSequenceMessage = @"WS-RM Last Sequence message sent.";
public const string TraceCodeWsrmSendSequenceMessage = @"WS-RM Sequence message sent.";
public const string TraceCodeWsrmSequenceFaulted = @"A WS-RM sequence has faulted.";
public const string TraceCodeChannelConnectionDropped = @"Channel connection was dropped";
public const string TraceCodeAsyncCallbackThrewException = @"An async callback threw an exception!";
public const string TraceCodeMetadataExchangeClientSendRequest = @"The MetadataExchangeClient is sending a request for metadata.";
public const string TraceCodeMetadataExchangeClientReceiveReply = @"The MetadataExchangeClient received a reply.";
public const string TraceCodeWarnHelpPageEnabledNoBaseAddress = @"The ServiceDebugBehavior Help Page is enabled at a relative address and cannot be created because there is no base address.";
public const string TraceCodeTcpConnectError = @"The TCP connect operation failed.";
public const string TraceCodeTxSourceTxScopeRequiredIsTransactedTransport = @"The transaction '{0}' was received for operation '{1}' from a transacted transport, such as MSMQ.";
public const string TraceCodeTxSourceTxScopeRequiredIsTransactionFlow = @"The transaction '{0}' was flowed to operation '{1}'.";
public const string TraceCodeTxSourceTxScopeRequiredIsAttachedTransaction = @"The transaction '{0}' was received for operation '{1}' from an InstanceContext transaction.";
public const string TraceCodeTxSourceTxScopeRequiredIsCreateNewTransaction = @"The transaction '{0}' for operation '{1}' was newly created.";
public const string TraceCodeTxCompletionStatusCompletedForAutocomplete = @"The transaction '{0}' for operation '{1}' was completed due to the TransactionAutoComplete OperationBehaviorAttribute member being set to true.";
public const string TraceCodeTxCompletionStatusCompletedForError = @"The transaction '{0}' for operation '{1}' was completed due to an unhandled execution exception.";
public const string TraceCodeTxCompletionStatusCompletedForSetComplete = @"The transaction '{0}' for operation '{1}' was completed due to a call to SetTransactionComplete.";
public const string TraceCodeTxCompletionStatusCompletedForTACOSC = @"The transaction '{0}' was completed when the session was closed due to the TransactionAutoCompleteOnSessionClose ServiceBehaviorAttribute member.";
public const string TraceCodeTxCompletionStatusCompletedForAsyncAbort = @"The transaction '{0}' for operation '{1}' was completed due to asynchronous abort.";
public const string TraceCodeTxCompletionStatusRemainsAttached = @"The transaction '{0}' for operation '{1}' remains attached to the InstanceContext.";
public const string TraceCodeTxCompletionStatusAbortedOnSessionClose = @"The transaction '{0}' was aborted because it was uncompleted when the session was closed and the TransactionAutoCompleteOnSessionClose OperationBehaviorAttribute was set to false.";
public const string TraceCodeTxReleaseServiceInstanceOnCompletion = @"The service instance was released on the completion of the transaction '{0}' because the ReleaseServiceInstanceOnTransactionComplete ServiceBehaviorAttribute was set to true.";
public const string TraceCodeTxAsyncAbort = @"The transaction '{0}' was asynchronously aborted.";
public const string TraceCodeTxFailedToNegotiateOleTx = @"The OleTransactions protocol negotiation failed for coordination context '{0}'.";







public const string TraceCodeActivatingMessageReceived = @"Activating message received.";
public const string TraceCodeDICPInstanceContextCached = @"InstanceContext cached for InstanceId {0}.";
public const string TraceCodeDICPInstanceContextRemovedFromCache = @"InstanceContext for InstanceId {0} removed from cache.";
public const string TraceCodeInstanceContextBoundToDurableInstance = @"DurableInstance's InstanceContext refcount incremented.";
public const string TraceCodeInstanceContextDetachedFromDurableInstance = @"DurableInstance's InstanceContext refcount decremented.";
public const string TraceCodeContextChannelFactoryChannelCreated = @"ContextChannel created.";
public const string TraceCodeContextChannelListenerChannelAccepted = @"A new ContextChannel was accepted.";
public const string TraceCodeContextProtocolContextAddedToMessage = @"Context added to Message.";
public const string TraceCodeContextProtocolContextRetrievedFromMessage = @"Context retrieved from Message.";
public const string TraceCodeWorkflowServiceHostCreated = @"WorkflowServiceHost created.";
public const string TraceCodeServiceDurableInstanceDeleted = @"ServiceDurableInstance '{0}' deleted from persistence store.";
public const string TraceCodeServiceDurableInstanceDisposed = @"ServiceDurableInstance '{0}' disposed.";
public const string TraceCodeServiceDurableInstanceLoaded = @"ServiceDurableInstance loaded from persistence store.";
public const string TraceCodeServiceDurableInstanceSaved = @"ServiceDurableInstance saved to persistence store.";
public const string TraceCodeWorkflowDurableInstanceLoaded = @"WorkflowDurableInstance '{0}' loaded.";
public const string TraceCodeWorkflowDurableInstanceActivated = @"WorkflowDurableInstance '{0}' activated.";
public const string TraceCodeWorkflowDurableInstanceAborted = @"WorkflowDurableInstance aborted.";
public const string TraceCodeWorkflowOperationInvokerItemQueued = @"Work item enqueued.";
public const string TraceCodeWorkflowRequestContextReplySent = @"Reply sent for InstanceId {0}.";
public const string TraceCodeWorkflowRequestContextFaultSent = @"Fault Sent for InstanceId {0}.";
public const string TraceCodeSqlPersistenceProviderSQLCallStart = @"Sql execution started.";
public const string TraceCodeSqlPersistenceProviderSQLCallEnd = @"Sql execution complete.";
public const string TraceCodeSqlPersistenceProviderOpenParameters = @"SqlPersistenceProvider.Open() parameters.";
public const string TraceCodeSyncContextSchedulerServiceTimerCancelled = @"SynchronizationContextWorkflowSchedulerService - Timer {0} cancelled.";
public const string TraceCodeSyncContextSchedulerServiceTimerCreated = @"SynchronizationContextWorkflowSchedulerService - Timer {0} created for InstanceId {1}.";
public const string TraceCodeSyndicationReadFeedBegin = @"Reading of a syndication feed started.";
public const string TraceCodeSyndicationReadFeedEnd = @"Reading of a syndication feed completed.";
public const string TraceCodeSyndicationReadItemBegin = @"Reading of a syndication item started.";
public const string TraceCodeSyndicationReadItemEnd = @"Reading of a syndication item completed.";
public const string TraceCodeSyndicationWriteFeedBegin = @"Writing of a syndication feed started.";
public const string TraceCodeSyndicationWriteFeedEnd = @"Writing of a syndication feed completed.";
public const string TraceCodeSyndicationWriteItemBegin = @"Writing of a syndication item started.";
public const string TraceCodeSyndicationWriteItemEnd = @"Writing of a syndication item completed.";
public const string TraceCodeSyndicationProtocolElementIgnoredOnRead = @"Syndication element with name '{0}' and namespace '{1}' ignored on read.";
public const string TraceCodeSyndicationProtocolElementIgnoredOnWrite = @"Syndication element with name '{0}' and namespace '{1}' was not written.";
public const string TraceCodeSyndicationProtocolElementInvalid = @"Syndication element with name '{0}' and namespace '{1}' is invalid.";
public const string TraceCodeWebUnknownQueryParameterIgnored = @"HTTP query string parameter with name '{0}' was ignored.";
public const string TraceCodeWebRequestMatchesOperation = @"Incoming HTTP request with URI '{0}' matched operation '{1}'.";
public const string TraceCodeWebRequestDoesNotMatchOperations = @"Incoming HTTP request with URI '{0}' does not match any operation.";






public const string InternalException = @"An error occurred within Windows Communication Foundation. Applications should not attempt to handle this error.";
public const string CrossDomainError = @"An error occurred while trying to make a request to URI '{0}'. This could be due to attempting to access a service in a cross-domain way without a proper cross-domain policy in place, or a policy that is unsuitable for SOAP services. You may need to contact the owner of the service to publish a cross-domain policy file and to ensure it allows SOAP-related HTTP headers to be sent. This error may also be caused by using internal types in the web service proxy without using the InternalsVisibleToAttribute attribute. Please see the inner exception for more details.";
public const string MissingReferenceToExtensionsDll = @"An exception occured when initializing duplex channels. Please ensure your application .xap package contains the assembly System.ServiceModel.Extensions.dll.";




public const string ConfigUnrecognizedElement = @"Unrecognized element '{0}' in service reference configuration. Note that only a subset of the Windows Communication Foundation configuration functionality is available in Silverlight.";
public const string ConfigUnsupportedElement = @"Element '{0}' in service reference configuration is not supported and can only be empty. Note that only a subset of the Windows Communication Foundation configuration functionality is available in Silverlight.";
public const string ConfigUnrecognizedAttribute = @"Unrecognized attribute '{0}' in service reference configuration. Note that attribute names are case-sensitive. Note also that only a subset of the Windows Communication Foundation configuration functionality is available in Silverlight. ";
public const string ConfigInvalidAttribute = @"Attribute '{0}' on the '{1}' element in service reference configuration is missing or has an invalid value.";
public const string ConfigFileMissing = @"Cannot find 'ServiceReferences.ClientConfig' in the .xap application package. This file is used to configure client proxies for web services, and allows the application to locate the services it needs. Either include this file in the application package, or modify your code to use a client proxy constructor that specifies the service address and binding explicitly. Please see inner exception for details.";
public const string ConfigFileFormat = @"An error occurred while attempting to read ServiceReferences.ClientConfig. This file is used to configure client proxies for web services, and allows the application to locate the services it needs. Please see inner exception for details.";

public const string ConfigTypeLoadError = @"Type '{0}' cannot be loaded. Please ensure your application .xap package contains the assembly {1}.";
public const string ConfigElementMustBeEmpty = @"Element '{0}' must be empty in service reference configuration.";
public const string UserNameCannotBeEmpty = @"The username cannot be empty.";
public const string NoSyncProgrammingInSL = @"Specified method is not supported because the synchronous programming model is not available in Silverlight.";
public const string NoStreamingTransferInSL = @"Specified method is not supported because streamed requests are not available in Silverlight.";
public const string NoExtensibleObjectsInSL = @"Specified method is not supported because Extensible Objects are not supported in Silverlight.";
public const string NotSupportedHttpWebRequestHeader = @"'{0}' header on HttpWebRequest is not supported in Silverlight.";
public const string NotSupportedHttpWebRequestCookieContainer = @"CookieContainer is not supported when using a browser-based HTTP stack. Cookies will be automatically managed by the browser. To gain manual control over cookies, switch to a different HTTP stack, for example by using WebRequest.RegisterPrefix with WebRequestCreator.ClientHttp.";
public const string MultipleCCbesInParameters = @"More than one HttpCookieContainerBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple HttpCookieContainerBindingElements in a CustomBinding. Remove all but one of these elements.";
public const string ContractHasSyncOperations = @"The contract '{0}' contains synchronous operations, which are not supported in Silverlight. Split the operations into ""Begin"" and ""End"" parts and set the AsyncPattern property on the OperationContractAttribute to 'true'. Note that you do not have to make the same change on the server.";
public const string CookieContainerBindingElementNeedsHttp = @"The HttpCookieContainerBindingElement can only be used with HTTP (or HTTPS) transport.";
}
}